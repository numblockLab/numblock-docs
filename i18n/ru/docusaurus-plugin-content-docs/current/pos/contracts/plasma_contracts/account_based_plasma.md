---
id: account_based_plasma
title: Plasma на базе аккаунтов
description: Реализация плазмы на основе аккаунта.
keywords:
  - docs
  - matic
  - Account Based Plasma
  - polygon
  - implementation
image: https://matic.network/banners/matic-network-16x9.png
---

# Plasma на базе аккаунтов {#account-based-plasma}

Polygon Plasma использует модель, аналогичную [Plasma MoreVP](https://ethresear.ch/t/more-viable-plasma/2160), но предполагает **реализацию на базе аккаунтов** в отличие от других вариантов реализации на базе UTXO. Сайдчейн совместим с EVM. Используя механизм MoreVP, мы также устраняем необходимость в подтверждающей подписи.

## Уровень PoS и checkpoint {#pos-layer-and-checkpoints}

В сети Polygon используется двойная стратегия на основе доказательства доли владения (Proof of Stake) на уровне чекпойнтинга и блок продюсеров на уровне блок продюсеров для достижения более быстрого времени блока и обеспечения окончательности основной цепочки с использованием checkpoint и доказательств мошенничества.

На уровне чекпойнтинга в сети Polygon для каждых нескольких блоков на уровне блоков сети Polygon валидатор (имеющий достаточную сумму залога) создает checkpoint в основной цепочке после проверки всех блоков на уровне блоков и создания дерева Меркла из хэшей блока с момента последнего checkpoint.

Помимо обеспечения окончательности в основной цепочке checkpoint играют роль в выводе активов, поскольку они содержат подтверждения сжигания (вывода) токенов в случае вывода активов пользователем. Это позволяет пользователям подтверждать свои оставшиеся токены в корневом контракте, используя доказательство Меркла Патрисии и доказательство блока заголовка. Обратите внимание, что для подтверждения оставшихся токенов блок заголовка должен быть зафиксирован в корневой цепочке через PoS (держателей стейка). В процессе вывода как обычно взимается комиссия за газ Ethereum. Мы активно используем checkpoint для обеспечения стратегий выхода.

## Журналы событий по принципу UTXO {#utxo-like-event-logs}

При совершении трансферов ERC20/ERC721 эта задача достигается за счет использования структуры данных журнала событий по принципу UTXO. Ниже для справки приведено событие `LogTransfer`.

```jsx
event LogTransfer(
    address indexed token,
    address indexed from,
    address indexed to,
    uint256 amountOrTokenId,
    uint256 input1, // previous account balance of the sender
    uint256 input2, // previous account balance of the receiver
    uint256 output1, // new account balance of the sender
    uint256 output2 // new account balance of the receiver
);
```

То есть каждый трансфер ERC20/ERC721 приводит к созданию такого события, и предыдущие остатки отправителя и получателя (`input1` и `input2`) становятся входными данными (по принципу UTXO) для транзакции, а новые суммы остатков становятся выходными данными (`output1` и `output2`). Трансферы отслеживаются путем сопоставления всех связанных с ними событий `LogTransfer`.

## Стратегии выхода {#exit-games}

Поскольку блоки производятся одним блок продюсером (или очень небольшим числом блок продюсеров), это создает возможности для мошенничества. Мы кратко рассмотрим сценарии атак, а затем поговорим о том, как Plasma гарантирует защиту пользователей.

## Векторы атак {#attack-vectors}

### Вредоносный оператор {#malicious-operator}
Ниже рассмотрены сценарии того, как у оператора могут возникнуть недобросовестные намерения и как он может попытаться обмануть систему.

1. Токены из ниоткуда/двойной расход/неправильно оформленные квитанции, которые мошенническим образом завышают (в случае аккаунта, управляемого оператором)/занижают (в случае пользователя) остаток токенов.
2. Недоступность данных. Предположим, что после того, как пользователь совершил транзакцию, оператор включает эту транзакцию в блок Plasma, но делает данные цепочки недоступными для пользователя. В этом случае, если пользователь инициирует выход из более старой транзакции, его действия могут быть оспорены в цепочке на основании демонстрации его последней транзакции. Это может легко разочаровать пользователя.
3. Недопустимый checkpoint. В худшем случае оператор может выполнить пункты A.1 и(или) A.2 и вступить в сговор с валидаторами, чтобы зафиксировать эти недействительные транзакции в корневой цепочке.
4. Остановка работы сайдчейна. Оператор прекращает создание блоков, и формирование цепочки останавливается. Если в течение определенного времени checkpoint не отправляется, можно пометить сайдчейн в корневой цепочке на основании его остановки. После этого становится невозможна отправка дополнительных checkpoint.

По причинам, указанным выше, или по другим причинам, если цепочка Plasma оказалась подвержена мошенническому вмешательству, пользователям необходимо начать массовый выход, и мы стремимся обеспечить механизмы выхода в корневой цепочке, которыми пользователи могут воспользоваться, когда и если это потребуется.

### Вредоносный пользователь {#malicious-user}

1. Пользователь инициирует выход из фиксированной транзакции, но продолжает расходовать токены в сайдчейне. Это похоже на двойной расход, но происходит в 2 цепочках.

Мы опираемся на идеи [MoreVp 7](https://ethresear.ch/t/more-viable-plasma/2160). Если кратко, то MoreVP вводит новый способ расчета приоритетности выхода, который называется приоритетом «новейших входных данных». Вместо того, чтобы упорядочить выходы по давности выходных данных, moreVP упорядочивает выходы по давности новейших входных данных. В результате выходы на основе выходных данных, даже если они включаются в удерживаемые блоки после транзакций «из ниоткуда», будут корректно обработаны при условии, что они проистекают только из действительных входных данных. Мы определяем команду `getAge`, которая присваивает давность включенной транзакции. Она определяется в соответствии с разделом о [минимальных требованиях для жизнеспособности сайдчейна Plasma 1](https://ethresear.ch/t/minimal-viable-plasma/426).

```jsx
function getAge(receipt) {
  const { headerNumber, plasmaBlockNum, txindex, oindex } = receipt
  return f(headerNumber, plasmaBlockNum, txindex, oindex) // multiplied with their respective weights
}
```

## Сценарии выхода {#exit-scenarios}

Давайте введем определенную терминологию, прежде чем продолжить обсуждение сценариев выхода:

- **Лицо, выводящее активы**: пользователь, желающий выйти из цепочки Plasma.
- **Зафиксированная транзакция**: транзакция, которая была включена в блок цепочки Polygon и прошла чекпойнтинг в корневой цепочке.
- **Расходная транзакция**: транзакция, которая изменяет остаток токенов пользователя в ответ на действие, под которым подписался пользователь (не включает входящие трансферы токенов). Это может быть инициированный пользователем трансфер, транзакция сжигания и т. д.
- **Контрольная транзакция**: транзакция, непосредственно предшествующая выходной транзакции для конкретного пользователя и токена. Как определено в нашей схеме UTXO на основе остатка по счету аккаунта, выходные данные контрольной транзакции становятся входными данными транзакции, с которой совершается выход.
- **Приоритетность выхода по принципу MoreVP**: давность новейших входных данных (среди контрольных транзакций) для конкретной транзакции. Чаще всего используется для расчета приоритетности выхода.

### Жетоны {#burn-tokens}

Чтобы выйти из сайдчейна, пользователь совершает транзакцию по *выводу или сжиганию токенов* в цепочке Plasma. Эта транзакция создаст событие `Withdraw`.

```jsx
event Withdraw(
    address indexed token,
    address indexed from,
    uint256 amountOrTokenId,
    uint256 input1,
    uint256 output1
);
```

Здесь `input1` означает предыдущий остаток пользователя по рассматриваемому виду токена, а `output1` означает число токенов, оставшихся в сайдчейне. Этот дизайн согласуется с нашей схемой *UTXO* на базе аккаунтов. Для вывода токенов в основной цепочке пользователь предоставляет квитанцию об этой транзакции по выводу активов. Ссылаясь на эту квитанцию, пользователь также должен предоставить следующее:

1. Доказательство Меркла о включении квитанции в блок сайдчейна (`receiptsRoot`)
2. Доказательство Меркла о включении транзакции в блок сайдчейна (`transactionsRoot`)
3. Доказательство включения заголовка блока сайдчейна в checkpoint в корневой цепочке.

```jsx
startExit(withdrawTx, proofOfInclusion /* of the withdrawTx in the checkpoint */) {
  Verify inclusion of withdrawTx in checkpoint using proofOfInclusion
  Verify msg.sender == ecrecover(withdrawTx)

  uint age = getAge(withdrawTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}
```

Всякий раз, когда пользователь желает выйти из цепочки Plasma, он (или лицо, абстрагированное своим клиентским приложением, т.е. кошельком) должен сжечь токены в сайдчейне, дождаться чекпойнтинга транзакции и затем начать выход из прошедшей чекпойнтинг транзакции по выводу активов.

### Выход из последних трансферов ERC20/721 (MoreVP) {#exit-from-the-last-erc20-721-transfers-morevp}

Рассмотрим сценарий, в котором пользователь совершил трансфер ERC20 в сайдчейне. Оператор добавил транзакцию из ниоткуда непосредственно перед трансфером пользователя и вступил в сговор с валидаторами, чтобы провести этот блок через checkpoint. В этом сценарии и в более общем плане в векторах атак, описанных выше в пунктах с А1 по A3, у пользователя могло не быть возможности сжечь свои токены до добавления недобросовестной транзакции, и, следовательно, он будет вынужден начать выход из последней транзакции, прошедшей чекпойнтинг в корневой цепочке. По этой причине, помимо выхода путем сжигания токенов, нам необходимо поддерживать возможность выхода из разных видов транзакций, в том числе из трансферов ERC20/721. Продолжая рассматривать этот вектор атаки, разбиваем его на 2 сценария:

**Исходящий трансфер:** я передал несколько токенов пользователю, но я заметил, что оператор добавил недобросовестную транзакцию в блок/checkpoint, прежде чем добавить мою трансферную транзакцию. Мне нужно начать выход из цепочки. Я начну выход из трансферной транзакции. В соответствии с принципами MoreVP, мне будет нужно указать контрольную транзакцию (*входные данные UTXO*), которая будет определять приоритетность выхода. Итак, я буду ссылаться на транзакцию, которая обновила мой остаток токенов и непосредственно предшествовала исходящей трансферной транзакции.

```jsx
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the user after the input tx was executed >= tokens being transferred in the exitTx
  Verify msg.sender == ecrecover(exitTx)

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

**Входящий трансфер:** я заметил, что оператор добавил недобросовестную транзакцию в блок/checkpoint, прежде чем добавить мою транзакцию входящего трансфера. Я начну выход из транзакции входящего трансфера, сославшись на остаток контрагента, поскольку в этом случае *входными данными UTXO* является остаток токенов контрагента.

```
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the counterparty after the input tx was executed >= tokens being transferred in the exitTx
  Verify input.sender == ecrecover(exitTx) && input.receiver == msg.sender

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

### Выход из транзакции в полете (MoreVP) {#exit-from-an-in-flight-transaction-morevp}

Этот метод предназначен для решения проблемы сценария недоступности данных. Допустим, я совершил транзакцию, но из-за отсутствия данных мне неизвестно, была ли эта транзакция добавлена. Я могу начать выход из этой текущей транзакции, сославшись на последнюю транзакцию, прошедшую чекпойнтинг. Пользователям не следует совершать никаких транзакций после начала выхода по принципу MoreVP; в противном случае их действия будут оспорены.

**Примечание:** при выходе из механизма по принципу MoreVP пользователь может инициировать выход, указав контрольные транзакции и выходную транзакцию и разместив небольшую сумму `exit bond`. При любой попытке выхода, если выход успешно оспорен, он отменяется, а выходной залог конфискуется.

## Ограничения {#limitations}

1. Большой объем доказательств: доказательство Меркла о добавлении транзакции и доказательство Меркла о добавлении блока (который содержит эту транзакцию) в checkpoint.
2. Массовый выход: если оператор совершает недобросовестное действие, пользователям необходимо начать массовый выход.

Эта спецификация еще формируется, и мы будем признательны за любую обратную связь, которая поможет нам улучшить ее или полностью переработать, если этот дизайн имеет неразрешимые недостатки. Реализация — это работа, которая находится в процессе нашего хранилища [контрактов.](https://github.com/maticnetwork/contracts)