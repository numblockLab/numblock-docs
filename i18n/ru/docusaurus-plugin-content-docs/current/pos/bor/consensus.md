---
id: consensus
title: Консенсус Bor
description: Механизм Bor
keywords:
  - docs
  - matic
  - Bor Consensus
  - polygon
image: https://matic.network/banners/matic-network-16x9.png
---
import useBaseUrl from '@docusaurus/useBaseUrl';

# Консенсус Bor {#bor-consensus}

Консенсус Bor основан на консенсусе Clique: [https://eips.ethereum.org/EIPS/eip-225](https://eips.ethereum.org/EIPS/eip-225). Clique работает с несколькими заранее заданными производителями. Все продюсеры голосуют за новых продюсеров, используя Clique API. Они принимают повороты создания блоков.

Бор подключает новых продюсеров с помощью механизма управления диапазоном и спринтом.

## Валидаторы {#validators}

Polygon — это система Proof-of-Stake. Любой желающий может застейкать свои токены Matic на смарт-контракте Ethereum (стейкинг контракте) и стать валидатором системы.

```jsx
function stake(
	uint256 amount,
	uint256 heimdallFee,
	address signer,
	bool acceptDelegation
) external;
```

Как только валидаторы становятся активными на Heimdall, они выбираются в качестве продюсеров через модуль `bor`.

Проверьте обзор Bor, чтобы понять управление диапазона, чтобы получить более подробную информацию: [Обзор Bor](https://www.notion.so/Bor-Overview-c8bdb110cd4d4090a7e1589ac1006bab)

## Диапазон блоков {#span}

Логически определенный набор блоков, для которых выбирается набор валидаторов из всех доступных валидаторов. Heimdall предоставляет сведения о диапазоне через API-интерфейсы сведений о диапазоне.

```go
// HeimdallSpan represents span from heimdall APIs
type HeimdallSpan struct {
	Span
	ValidatorSet      ValidatorSet `json:"validator_set" yaml:"validator_set"`
	SelectedProducers []Validator  `json:"selected_producers" yaml:"selected_producers"`
	ChainID           string       `json:"bor_chain_id" yaml:"bor_chain_id"`
}

// Span represents a current bor span
type Span struct {
	ID         uint64 `json:"span_id" yaml:"span_id"`
	StartBlock uint64 `json:"start_block" yaml:"start_block"`
	EndBlock   uint64 `json:"end_block" yaml:"end_block"`
}

// Validator represents a volatile state for each Validator
type Validator struct {
	ID               uint64         `json:"ID"`
	Address          common.Address `json:"signer"`
	VotingPower      int64          `json:"power"`
	ProposerPriority int64          `json:"accum"`
}
```

Geth (в данном случае Bor) использует блок `snapshot` для хранения данных состояния для каждого блока, включая данные, связанные с консенсусом.

Каждый валидатор в диапазоне имеет право голоса. В зависимости от их мощности они выбираются в качестве продюсеров блоков. Чем выше мощность, тем выше вероятность стать продюсером блоков. Bor использует для этого алгоритм Tendermint. Источник: [https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go](https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go)

## Спринт {#sprint}

Набор блоков в диапазоне, для которого выбран единственный блок продюсер для создания блоков. Размер спринта является фактором размера диапазона. Бор использует `validatorSet` для получения текущего автора предложения/продюсера для текущего спринта.

```go
currentProposerForSprint := snap.ValidatorSet().Proposer
```

Помимо текущего автора предложения, Bor выбирает резервных продюсеров.

## Авторизация блока {#authorizing-a-block}

Продюсеры в Bor также называются подписантами, поскольку для авторизации блока в сети продюсер должен подписать хэш блока, содержащий **все, кроме самой подписи**. Это означает, что хэш содержит все поля заголовка, а также `extraData` за исключением 65-байтового суффикса подписи.

Этот хэш подписывается с использованием стандартной кривой `secp256k1`, и полученная 65-байтовая подпись встраивается в `extraData` в качестве завершающего 65-байтового суффикса.

Каждому подписанному блоку назначается сложность, которая придает вес блоку. Подписание в свою очередь весит больше (`DIFF_INTURN`), чем подписание вне очереди (`DIFF_NOTURN`).

### Стратегии авторизации {#authorization-strategies}

До тех пор, пока продюсеры соответствуют указанным выше критериям, они могут авторизовать и распространять блоки по своему усмотрению. Следующая стратегия уменьшит сетевой трафик и сократит количество малых ответвлений, поэтому рекомендуется использовать эту функцию:

- Если продюсеру разрешено подписывать блок (есть в авторизованном списке)
    - Рассчитайте оптимальное время подписи следующего блока (родительский + `Period`)
    - Если продюсер в очереди, ждите точного времени получения, подписывайте и транслируйте сразу
    - Если продюсер вне очереди, задержите подписание с помощью `wiggle`

Эта небольшая стратегия гарантирует, что продюсер в очереди (чей блок весит больше) будет иметь небольшое преимущество в подписании и распространении по сравнению с подписантами вне очереди. Кроме того, схема допускает небольшое масштабирование с увеличением количества продюсеров.

### Подписание вне очереди {#out-of-turn-signing}

Bor выбирает несколько блок продюсеров в качестве резервных, когда продюсер не производит блок в свою очередь. Это может произойти по разным причинам, например:

- Нод блок продюсера не работает
- Блок продюсер пытается удержать блок
- Блок продюсер не создает блок намеренно.

Когда происходит что-то из вышеперечисленного, срабатывает резервный механизм Bor.

В любой момент времени набор валидаторов сохраняется в виде массива, отсортированного на основе адреса подписавшего. Предположим, что набор валидаторов упорядочен как «A», «B», «C», «D», и что настала очередь «C» создать блок. Если «C» не производит блок в течение достаточно продолжительного времени, очередь переходит к «D». Если и «D» не создает, очередь переходит к «A», а затем к «B».

Поскольку перед тем, как «C» создаст и распространит блок должно пройти некоторое время, резервные валидаторы будут ждать определенное время, прежде чем начать создавать блок. Эта задержка называется покачивание (wiggle).

### Покачивание {#wiggle}

Покачивание — это время, которое продюсер должен ждать, прежде чем начать производить блок.

- Скажем, последний блок (n-1) был произведен в момент времени `t`.
- Мы устанавливаем обязательную минимальную временную задержку между текущим и следующим блоком с помощью переменного параметра `Period`.
- В идеальных условиях «C» будет ждать `Period` перед тем как создать и распространить блок. Поскольку время блока в Polygon проектируется довольно низким (2-4 с.), предполагается, что задержка распространения также равна `Period`.
- Таким образом, если «D» не видит новый блок в течение `2 * Period`, «D» немедленно начинает создавать блок. В частности, время покачивания «D» определяется как `2 * Period * (pos(d) - pos(c))`, где `pos(d) = 3` и `pos(c) = 2` в наборе валидаторов. Если мы предполагаем, что `Period = 1`, то покачивание для «D» равно 2 с.
- Теперь, если «D» также не производит блок, «A» начнет производить его, когда истечет время покачивания — `2 * Period * (pos(a) + len(validatorSet) - pos(c)) = 4s`.
- Аналогично, покачивание для «C» равно `6s`

### Разрешение ответвлений {#resolving-forks}

Несмотря на то, что описанный выше механизм в определенной степени повышает надежность цепочки, он вводит возможность ответвлений. На самом деле вполне возможно, что «C» создал блок, но задержка в распространении была больше, чем ожидалось, и, следовательно, «D» также создал блок, так что это приводит как минимум к 2 ответвлениям.

Решение простое — выбор цепочки с большей сложностью. Но тогда вопрос в том, как мы определяем сложность блока в нашей установке?

### Сложность {#difficulty}

- Сложность блока, созданного подписавшим в свою очередь (скажем, «C»), определяется как наивысшая = `len(validatorSet)`.
- Поскольку «D» — продюсер, следующий в очереди, то если (когда) возникает ситуация, что «D» производит блок, сложность блока будет определяться так же, как и в покачивании, как `len(validatorSet) - (pos(d) - pos(c))`, что равно `len(validatorSet) - 1`
- Сложность блока, создаваемого «A» при выполнении функции резервного копирования, становится равной `len(validatorSet) - (pos(a) + len(validatorSet) - pos(c))`, что составляет `2`

Теперь, когда мы определили сложность каждого блока, сложность ответвления представляет собой просто сумму сложностей блоков в этом ответвлении. В случае, когда необходимо выбрать ответвление, выбирается ответвление с более высокой сложностью, поскольку это значит, что блоки были созданы блок продюсерами в свою очередь. Это просто для того, чтобы предоставить пользователю Bor некоторое ощущение завершенности.

## Показать изменение {#view-change}

После каждого диапазона Bor меняет вид. Это означает, что он подбирает новых продюсеров для следующего диапазона.

### Фиксация диапазона {#commit-span}

Когда текущий диапазон подходит к концу (в частности, в конце предпоследнего спринта в диапазоне), Bor берет новый диапазон из Heimdall. Это простой HTTP-вызов нода Heimdall. Как только эти данные получены, выполняется вызов `commitSpan` контракта genesis BorValidatorSet через системный вызов.

Bor также устанавливает байты продюсеров в заголовок блока. Это необходимо при быстрой синхронизации Bor. Во время быстрой синхронизации Bor массово синхронизирует заголовки и проверяет, созданы ли блоки авторизованными продюсерами.

В начале каждого спринта Bor извлекает байты заголовка из предыдущего заголовка для следующих продюсеров и начинает создавать блоки на основе алгоритма `ValidatorSet`.

Пример заголовка блока:

```js
header.Extra = header.Vanity + header.ProducerBytes /* optional */ + header.Seal
```

<img src={useBaseUrl("img/Bor/header-bytes.svg")} />

## Синхронизация состояния из цепочки Ethereum {#state-sync-from-ethereum-chain}

Bor предоставляет механизм, при котором некоторые конкретные события в основной цепочке Ethereum передаются в Bor. Таким же образом обрабатываются депозиты на контракты Plasma.

1. Любой контракт на Ethereum может вызвать [syncState](https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L33) в `StateSender.sol`. Этот вызов создает событие `StateSynced`: https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L38

  ```js
  event StateSynced(uint256 indexed id, address indexed contractAddress, bytes data)
  ```

2. Heimdall слушает эти события и `function proposeState(uint256 stateId)`вызовы, что таким `StateReceiver.sol`образом действует в качестве магазина для ожидающих изменения состояния. Обратите внимание, что транзакция `proposeState` будет обработана даже с нулевой комиссией за газ, если она выполняется одним из валидаторов в текущем наборе валидаторов: https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/StateReceiver.sol#L24

3. В начале каждого спринта Bor извлекает сведения об ожидающих изменениях состояния, используя состояния из Heimdall, и фиксирует их в состоянии Bor с помощью системного вызова. См. `commitState` здесь: https://github.com/maticnetwork/genesis-contracts/blob/f85d0409d2a99dff53617ad5429101d9937e3fc3/contracts/StateReceiver.sol#L41
