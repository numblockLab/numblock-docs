---
id: consensus
title: बोर सहमति
description: नए उत्पादकों को लाने के लिए बोर मैकेनिज्म
keywords:
  - docs
  - matic
  - Bor Consensus
  - polygon
image: https://matic.network/banners/matic-network-16x9.png
---
import useBaseUrl from '@docusaurus/useBaseUrl';

# बोर सहमति {#bor-consensus}

बोर सहमति क्लिक सहमति से प्रेरित है: [https://eips.ethereum.org/EIPS/eip-225](https://eips.ethereum.org/EIPS/eip-225). ethereum.org/EIPS/eip-225 क्लिक, कई पूर्व परिभाषित उत्पादकों के साथ काम करता है. सभी निर्माता Clique API का इस्तेमाल करके नए निर्माताओं पर वोट करते हैं. वे ब्लॉक बनाने में बदल जाते हैं.

बोर स्पैन और स्प्रिंट मैनेजमेंट मैकेनिज्म के ज़रिए नए निर्माताओं को ले लेता है.

## वैलिडेटर {#validators}

पॉलीगॉन एक प्रूफ़-ऑफ-स्टेक वाला सिस्टम है. कोई भी एथेरेयम स्मार्ट कॉन्ट्रैक्ट, "स्टेकिंग अनुबंध" पर अपने मैटिक टोकन को स्टेक पर लगा सकता है और सिस्टम के लिए एक वैलिडेटर बन सकता है.

```jsx
function stake(
	uint256 amount,
	uint256 heimdallFee,
	address signer,
	bool acceptDelegation
) external;
```

वैलिडेटरों के हेम्डल पर एक बार एक्टिव होने पर वे `bor`मॉड्यूल के ज़रिए एक निर्माता के तौर पर चुने जाते हैं.

विवरण में स्पैन मैनेजमेंट को अधिक समझने के लिए Check च करें : [बोर ओवरव्यू](https://www.notion.so/Bor-Overview-c8bdb110cd4d4090a7e1589ac1006bab)

## स्पैन {#span}

ब्लॉक का एक तार्किक रूप से परिभाषित सेट जिसके लिए सभी उपलब्ध वैलिडेटर्स में से वैलिडेटर्स का एक सेट चुना जाता है. हेम्डल स्पैन-डिटेल्स API के ज़रिए स्पैन से जुड़ा विस्तृत जानकारी देता है.

```go
// HeimdallSpan represents span from heimdall APIs
type HeimdallSpan struct {
	Span
	ValidatorSet      ValidatorSet `json:"validator_set" yaml:"validator_set"`
	SelectedProducers []Validator  `json:"selected_producers" yaml:"selected_producers"`
	ChainID           string       `json:"bor_chain_id" yaml:"bor_chain_id"`
}

// Span represents a current bor span
type Span struct {
	ID         uint64 `json:"span_id" yaml:"span_id"`
	StartBlock uint64 `json:"start_block" yaml:"start_block"`
	EndBlock   uint64 `json:"end_block" yaml:"end_block"`
}

// Validator represents a volatile state for each Validator
type Validator struct {
	ID               uint64         `json:"ID"`
	Address          common.Address `json:"signer"`
	VotingPower      int64          `json:"power"`
	ProposerPriority int64          `json:"accum"`
}
```

Geth (इस मामले में, बोर) सहमति से संबंधित डेटा के साथ-साथ हर एक ब्लॉक के लिए स्टेट डेटा स्टोर करने `snapshot`के लिए ब्लॉक का इस्तेमाल करता है.

स्पैन में हर वैलिडेटर के पास वोटिंग पावर है. उनके पावर के आधार पर, वे ब्लॉक निर्माता के तौर पर चुने जाते हैं. जितनी ज़्यादा पावर, उतनी ही ज़्यादा ब्लॉक निर्माता बनने की संभावना. बोर उसी के लिए Tendermint के अल्गोरिथम का इस्तेमाल करता है. स्रोत: [https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go](https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go)

## स्प्रिंट {#sprint}

एक स्पैन के भीतर ब्लॉक का एक समूह, जिसके लिए सिर्फ़ एक ब्लॉक निर्माता चुना जाता है, जो ब्लॉक बनाता है. स्प्रिंट का आकार स्पान के आकार का एक कारक है. बोर मौजूदा स्प्रिंट के लिए मौजूदा प्रपोज़ करने वाला/निर्माता पाने के लिए `validatorSet`का इस्तेमाल करता है.

```go
currentProposerForSprint := snap.ValidatorSet().Proposer
```

मौजूदा प्रपोज़र के अलावा, बोर बैकअप निर्माताओं को भी चुनता है.

## किसी ब्लॉक को ऑथोराइज़ करना {#authorizing-a-block}

बोर में निर्माताओं को साइनर भी कहा जाता है, चूंकि नेटवर्क के लिए ब्लॉक को ऑथोराइज़ करने के लिए निर्माता को ब्लॉक के हैश पर साइन करना होता है जिसमें खुद सिग्नेचर को छोड़कर बाकी **सब कुछ होता** है. इसका मतलब है कि हैश में 65-बाइट सिग्नेचर सफ़िक्स के अपवाद के साथ `extraData` और हेडर का हर एक फ़ील्ड होता है.

हैश पर स्टैंडर्ड `secp256k1` कर्व का इस्तेमाल करके साइन किया जाता है और जिसके नतीजतन 65-बाइट सिग्नेचर आखिर में लगने वाले 65-बाइट सफ़िक्स के तौर पर `extraData` में एम्बेडेड होता है.

साइन किए गए हर ब्लॉक एक डिफ़िकल्टी असाइन किया जाता है जो ब्लॉक पर प्रभाव डालता है. एक के बाद एक करके साइन करना बिना बारी के एक (`DIFF_INTURN`) के मुकाबले (`DIFF_NOTURN`) ज़्यादा प्रभाव डालता है.

### ऑथोराइज़ेशन की रणनीतियां {#authorization-strategies}

जब तक निर्माता ऊपर बताए गए विशेष निर्देशों का पालन करते हैं, तब तक उन्हें जैसा मुनासिब लगे उस तरह से ब्लॉक को अधिकृत और वितरित कर सकते हैं. हालांकि, नीचे सुझाई गई रणनीति नेटवर्क ट्रैफ़िक को कम करेगी और फ़ॉर्क को छोटा करेगी, इसलिए यह एक सुझाई गई ख़ूबी है:

- अगर निर्माता को ब्लॉक (अधिकृत की गई लिस्ट पर है) पर साइन करने की अनुमति है, तो
    - अगले ब्लॉक (पैरेंट + `Period`) के अधिकतम साइनिंग समय की गणना करें
    - अगर निर्माता की बारी है, तो आने के सटीक समय का इंतज़ार करे, तुरंत साइन करें और ब्रॉडकास्ट करें
    - अगर निर्माता की बारी नहीं है, तो `wiggle` से साइन में देरी करें

यह मामूली-सी रणनीति यह पक्का करेगी कि बारी से आने वाले निर्माता (जिनके ब्लॉक का प्रभाव ज़्यादा हो) के पास बिना बारी से आने वाले साइनरों के मुकाबले साइन और प्रोपगेट करने के लिए थोड़ी बढ़त हो. साथ ही, यह स्कीम निर्माताओं की संख्या में बढ़ोत्तरी के साथ थोड़ी-बहुत वृद्धि की अनुमति देती है.

### बिना बारी के साइन करना {#out-of-turn-signing}

बोर तब बैकअप के तौर पर कई ब्लॉक निर्माताओं को चुनता है जब बारी वाले निर्माता कोई ब्लॉक नहीं बनाते हैं. यह कई कारणों से हो सकता है, जैसे कि:

- ब्लॉक निर्माता नोड डाउन हो
- ब्लॉक निर्माता ब्लॉक को रोकने की कोशिश कर रहा हो
- ब्लॉक निर्माता किसी ब्लॉक को जान-बूझ कर नहीं बना रहा हो.

जब ऊपर बताई गई बातें होती हैं, तब बैकअप मैकेनिज्म हरकत में आता है.

किसी भी समय, वैलिडेटरों के समूह को उनके साइनर पते के आधार पर क्रमबद्ध सरणी के रूप में संग्रहीत किया जाता है. मान लिजिए कि वैलिडेटर का समूह A, B, C, D के अनुक्रम में हो और ब्लॉक बनाने की बारी C की हो. अगर C समय रहते कोई ब्लॉक नहीं बना पाता है, तो ब्लॉक बनाने की बारी D की होगी. अगर D नहीं बना पाता है, तो A की और उसके बाद B की बारी आएगी.

हालांकि, चूंकि C के द्वारा एक ब्लॉक बनाने और प्रोपगेट करने से पहले थोड़ा समय होगा, इसलिए बैकअप वैलिडेटर किसी ब्लॉक को बनाना शुरु करने से पहले एक निश्चित समय तक इंतज़ार करेंगे. समय की इस देरी को वीगल (wiggle) कहा जाता है.

### वीगल (wiggle) {#wiggle}

वीगल उस समय को कहते हैं, जब किसी निर्माता को ब्लॉक बनाना शुरु करने से पहले इंतज़ार करना चाहिए.

- माना कि आखिरी ब्लॉक (n-1) समय `t` पर बनाया गया था.
- हम एक वेरिएबल पैरामीटर `Period` के द्वारा मौजूदा और अगले ब्लॉक के बीच समय की कम से कम देरी को लागू करते हैं.
- आदर्श परिस्थितियों में, C `Period` के लिए इंतज़ार करेगा और फिर ब्लॉक को बनाएगा और प्रोपगेट करेगा. चूंकि पॉलीगॉन में ब्लॉक के समय को काफी कम (2-4 सेकंड) के लिए डिज़ाइन किया जा रहा है, इसलिए प्रोपगेशन में देरी को भी `Period` के बराबर वैल्यू का माना जाता है.
- इसलिए अगर D को समय पर नया ब्लॉक नहीं दिखता है`2 * Period`, तो D तुरंत एक ब्लॉक बनाना शुरू कर देता है. खासकर, D का वीगल टाइम `2 * Period * (pos(d) - pos(c))` के रूप में परिभाषित किया जाता है, जहां `pos(d) = 3` और `pos(c) = 2` वैलिडेटर समूह में होता हैं. माना कि `Period = 1`, D के लिए वीगल 2 सेकंड है.
- अब अगर D भी कोई ब्लॉक नहीं बनाता है, तो `2 * Period * (pos(a) + len(validatorSet) - pos(c)) = 4s` के वीगल टाइम के खत्म होने पर A एक ब्लॉक बनाना शुरू करेगा.
- इसी तरह, C के लिए वीगल `6s`होगा

### फ़ॉर्क का समाधान करना {#resolving-forks}

जबकि ऊपर बताया गया मैकेनिज्म चेन को एक हद तक मजबूती देता है, फिर भी यह फ़ॉर्क की संभावना पैदा करता है. ऐसा हो सकता है कि C एक ब्लॉक बनाए, लेकिन प्रोपगेशन में उम्मीद से ज़्यादा देरी हुई और इसलिए D ने भी एक ब्लॉक बनाया, इसलिए इसके कारण कम से कम 2 फ़ॉर्क पैदा होते हैं.

समाधान आसान है - ज़्यादा डिफ़िकल्टी वाले चेन को चुनें. लेकिन फिर सवाल यह है कि हम अपने सेटअप में किसी ब्लॉक की डिफ़िकल्टी को कैसे परिभाषित करते हैं?

### डिफ़िकल्टी {#difficulty}

- बारी वाले साइनर (माना कि c) द्वारा बनाए गए ब्लॉक के लिए डिफ़िकल्टी को सबसे ऊंचा = `len(validatorSet)` होने के लिए परिभाषित किया जाता है.
- चूंकि D वह निर्माता है जो लाइन में अगला है; तो अगर कहीं ऐसी परिस्थिति आए कि D ब्लॉक बना रहा हो, तो ब्लॉक के लिए डिफ़िकल्टी को उसी तरह परिभाषित किया जाएगा जैसा कि वीगल में `len(validatorSet) - (pos(d) - pos(c))` के तौर पर है जो कि `len(validatorSet) - 1`है
- बैकअप के तौर पर काम कर रहे A द्वारा बनाए जा रहे ब्लॉक के लिए डिफ़िकल्टी `len(validatorSet) - (pos(a) + len(validatorSet) - pos(c))` हो जाएगी जो कि `2`है

अब हर ब्लॉक की डिफ़िकल्टी को परिभाषित करने के बाद, किसी फ़ॉर्क की डिफ़िकल्टी बस उस फ़ॉर्क में सभी ब्लॉक की डिफ़िकल्टी का योग होगी. अगर ऐसा कोई मामला हो, जब फ़ॉर्क को चुनना पड़े, तो सबसे ज़्यादा डिफ़िकल्टी वाला फ़ॉर्क चुना जाता है, क्योंकि यह इस बात की सच्चाई का सबूत है कि ब्लॉक बारी-बारी वाले ब्लॉक निर्माताओं द्वारा बनाए गए थे. यह बस बोर पर यूज़र को फ़ाइनैलिटी का एहसास देना है.

## व्यू बदलें {#view-change}

हर स्पैन के बाद, बोर व्यू को बदल देता है. इसका मतलब है कि यह अगले स्पैन के लिए नए निर्माताओं को ले लेता है.

### कमिट स्पैन {#commit-span}

जब मौजूदा स्पैन खत्म होने वाला हो (खासकर, स्पैन में आखिरी से दूसरे स्प्रिंट के खत्म होने पर), तब बोर हेम्डल से एक नया स्पैन खींचता है. यह हेम्डल नोड के लिए एक मामूली HTTP कॉल है. इस डेटा को एकबार लाने पर, सिस्टम कॉल के ज़रिए BorValidatorSet Genesis अनुबंध के लिए एक `commitSpan` कॉल किया जाता है.

बोर ब्लॉक के हेडर में निर्माताओं के लिए बाइट भी सेट करता है. बोर के तेजी से समकालिक होने के दौरान यह ज़रूरी है. तेजी से समकालिक होने के दौरान, बोर एक साथ कई हेडर को समकालिक बनाता है और यह सत्यापित करता है कि क्या ब्लॉक अधिकृत निर्माताओं द्वारा बनाया गया है.

हर एक स्प्रिंट की शुरुआत में, बोर अगले निर्माताओं के लिए पिछले हेडर से हेडर बाइट लेता है और `ValidatorSet` अल्गोरिथम के आधार पर ब्लॉक बनाना शुरू करता है.

एक ब्लॉक के लिए हेडर कुछ ऐसा दिखता है:

```js
header.Extra = header.Vanity + header.ProducerBytes /* optional */ + header.Seal
```

<img src={useBaseUrl("img/Bor/header-bytes.svg")} />

## एथेरेयम चेन से स्टेट को समकालिक करें {#state-sync-from-ethereum-chain}

बोर एक ऐसा मैकेनिज्म देता है जहां मुख्य एथेरेयम चेन पर कुछ खास इवेंट बोर पर निर्भर होते हैं. यह भी बताता है कि प्लाज़्मा अनुबंधों में डिपॉज़िट कैसे संसाधित किए जाते हैं.

1. एथेरेयम पर कोई भी अनुबंध `StateSender.sol` में [syncState](https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L33) को कॉल कर सकता है. यह कॉल `StateSynced` इवेंट को एमिट करता है:https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L38

  ```js
  event StateSynced(uint256 indexed id, address indexed contractAddress, bytes data)
  ```

2. हेम्डल इन घटनाओं को सुनता है और इन कॉल करता है - इस `StateReceiver.sol`प्रकार लंबित स्टेट चेंज आईडी के लिए स्टोर के रूप `function proposeState(uint256 stateId)`में काम करता है. इस बात को नोट करें कि `proposeState` ट्रांज़ैक्शन तब तक 0 गैस फ़ीस के लिए भी संसाधित किया जाएगा जब तक कि यह मौजूदा वैलिडेटर समूह में किसी भी एक वैलिडेटर द्वारा बनाया जाता रहेगा: https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/StateReceiver.sol#L24

3. हर स्प्रिंट की शुरुआत में, बोर हेम्डल से स्टेट्स का इस्तेमाल करके पेंडिंग स्टेट चेज़ के बारे में विस्तृत जानकारी प्राप्त करता है और एक सिस्टम कॉल का इस्तेमाल करके उन्हें बोर स्टेट में डालता है. यहां `commitState`को देखें: https://github.com/maticnetwork/genesis-contracts/blob/f85d0409d2a99dff53617ad5429101d9937e3fc3/contracts/StateReceiver.sol#L41
