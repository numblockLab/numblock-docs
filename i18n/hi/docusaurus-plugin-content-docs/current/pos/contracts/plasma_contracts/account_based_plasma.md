---
id: account_based_plasma
title: अकाउंट पर आधारित प्लाज़्मा
description: प्लाज्मा का एक अकाउंट आधारित कार्यान्वयन
keywords:
  - docs
  - matic
  - Account Based Plasma
  - polygon
  - implementation
image: https://matic.network/banners/matic-network-16x9.png
---

# अकाउंट पर आधारित प्लाज़्मा {#account-based-plasma}

पॉलीगॉन प्लाज़्मा [प्लाज़्मा MoreVP](https://ethresear.ch/t/more-viable-plasma/2160) के जैसा ही मॉडल का अनुसरण करता है, लेकिन यह अन्य UTXO के आधार पर लागू करने के मुकाबले **अकाउंट के आधार पर लागू करना** है. साइडचेन EVM-संगत है. MoreVP कंस्ट्रक्शन का इस्तेमाल करने पर, हमें सिग्नेचरों को पुष्टि करने की ज़रूरत नहीं रहती है.

## पीओएस लेयर और चेकपॉइंट {#pos-layer-and-checkpoints}

पॉलीगॉन नेटवर्क चेकपॉइंट वाले लेयर पर भागीदारी के सबूत की दोहरी रणनीति का इस्तेमाल करता है और ज़्यादा तेज ब्लॉकटाइम हासिल करने के लिए ब्लॉक निर्माता लेयर पर ब्लॉक का इस्तेमाल करता है और चेकपॉइंट और धोखाधड़ी के सबूत का इस्तेमाल करके मुख्य चेन में फ़ाइनैलिटी प्राप्त करता है.

पॉलीगॉन नेटवर्क के चेकपॉइंट वाले लेयर पर, पॉलीगॉन नेटवर्क के ब्लॉक लेयर पर कुछ ब्लॉकों में से प्रत्येक के लिए, एक (पर्याप्त रूप से जुड़ा हुआ) वैलिडेटर ब्लॉक लेयर पर सभी ब्लॉक को वैलिडेट करने और आखिरी चेकपॉइंट के बाद से ब्लॉक हैश का मर्कल ट्री बनाने के बाद मुख्य चेन पर एक चेकपॉइंट बनाएगा.

चेकपॉइंट मेनचेन पर फ़ाइनैलिटी मुहैया कराने के अलावे विथड्रॉवल में एक भूमिका निभाते हैं, क्योंकि उनमें यूज़र विथड्रॉवल के इवेंट में टोकन का प्रूफ़-ऑफ़-बर्न (निकालना/विथड्रॉवल) शामिल होता है. यह यूज़र्स को पैट्रिसिया मर्कल सबूत और हेडर ब्लॉक सबूत का इस्तेमाल करके रुट अनुबंध पर अपने बाकी टोकन को साबित करने में सक्षम बनाता है. नोट करें कि बाकी बचे टोकन को साबित करने के लिए, हेडर ब्लॉक पॉस (स्टेकहोल्डर्स) के ज़रिए रुट चेन के लिए समर्पित होना चाहिए. विथड्रॉवल की प्रक्रिया हमेशा की तरह एथेरेयम गैस फीस देगी. हम एक्ज़िट गेम्स के लिए चेकपॉइंट का पूरा-पूरा फ़ायदा उठाते हैं.

## UTXO जैसे इवेंट लॉग {#utxo-like-event-logs}

ERC20/ERC721 ट्रांसफ़र के लिए, यह UTXO जैसे इवेंट लॉग डेटा स्ट्रक्चर का इस्तेमाल करके हासिल किया जाता है. संदर्भ के लिए एक `LogTransfer`इवेंट नीचे है.

```jsx
event LogTransfer(
    address indexed token,
    address indexed from,
    address indexed to,
    uint256 amountOrTokenId,
    uint256 input1, // previous account balance of the sender
    uint256 input2, // previous account balance of the receiver
    uint256 output1, // new account balance of the sender
    uint256 output2 // new account balance of the receiver
);
```

इसलिए, दरअसल हर ERC20/ERC721 ट्रांसफ़र इस इवेंट को उत्सर्जित करता है और भेजने वाले और पाने वाले (`input1` और `input2`) के पिछले बैलेंस ट्रांज़ैक्शन (tx) के लिए इनपुट (UTXO जैसे) बन जाते हैं और नए बैलेंस आउटपुट (`output1` और)`output2` बन जाते हैं. ट्रांसफ़र सभी संबंधित `LogTransfer`इवेंट को क्रम में रखते हुए निगरानी की जाती हैं.

## एक्ज़िट गेम्स {#exit-games}

चूंकि ब्लॉक सिंगल ब्लॉक निर्माता (या बहुत कम) द्वारा बनाए जाते हैं, इसलिए यह धोखाधड़ी को उजागर करता है. हम हमले से जुड़े परिदृश्यों पर संक्षेप में चर्चा करेंगे और फिर इस पर बात करेंगे कि प्लाज़्मा किसी यूज़र को सुरक्षित रखने कि कैसे गारंटी देता है.

## हमले के वाहक {#attack-vectors}

### दुर्भावनापूर्ण ऑपरेटर {#malicious-operator}
नीचे बताई गई चीज़ें उन परिदृश्यों के बारे में बताते हैं जहां ऑपरेटर खराबी पैदा कर सकता है और ठगने की कोशिश कर सकता है.

1. अनजान टोकन / डबल स्पेंड्स / छेड़छाड़ किए गए रिसिप्ट जो धोखाधड़ी करके टोकन बैलेंस को बढ़ाते (ऑपरेटर द्वारा कंट्रोल किए जाने वाले किसी अकाउंट के लिए) / घटाते (किसी यूज़र के लिए) हों.
2. किसी यूज़र द्वारा एक ट्रांज़ैक्शन भेजे जाने के बाद डेटा की अनुपलब्धता, चलिए मानते हैं कि ऑपरेटर ने प्लाज़्मा ब्लॉक में ट्रांज़ैक्शन शामिल किया लेकिन यूज़र के लिए चेन डेटा को अनुपलब्ध बना दिया. उस मामले में, अगर कोई यूज़र किसी पुराने ट्रांज़ैक्शन से एक्ज़िट करना शुरू करता है, तो उन्हें अपने सबसे हाल के ट्रांज़ैक्शन को दिखा कर ऑन-चेन चैलेंज किया जा सकता है. इससे यूज़र को आसानी से तकलीफ़ पहुँचाया जा सकता है.
3. खराब चेकपॉइंट, सबसे खराब हालात में कोई ऑपरेटर A.1 और(या) A.2 को परफ़ॉर्म कर सकता है और उन अमान्य स्टेट ट्रांज़िशन को रुट चेन में कमिट करने के लिए वैलिडेटरों के साथ मिलकर काम कर सकता है.
4. साइड चेन को रोकना, ऑपरेटर ब्लॉक बनाना बंद कर देता है और चेन रूक जाती है. अगर किसी खास समय के लिए चेकपॉइंट को सबमिट नहीं किया गया हो, तो ऐसा हो सकता है कि साइड चेन को रुट चेन पर रूके हुए के तौर पर चिह्नित कर दिया जाए. उसके बाद कोई और चेकपॉइंट सबमिट नहीं किया जा सकता है.

ऊपर या अन्यथा सूचीबद्ध किए गए कारणों के लिए, अगर प्लाज़्मा चेन नुकसानदेह बन जाए, तो यूज़र को बड़े पैमाने पर बाहर जाना और अगर जब कभी भी ऐसा समय आता है, तो हम रुट चेन पर एक्ज़िट कंस्ट्रक्शन मुहैया कराते हैं ताकि यूज़र इसका फ़ायदा उठा सके.

### दुर्भावनापूर्ण यूजर {#malicious-user}

1. यूज़र किसी कमिटेड ट्रांज़ैक्शन से बाहर निकलना शुरू कर देते है लेकिन साइड चेन पर टोकन खर्च करना जारी रखते है. डबल स्पेंडिंग के जैसा ही लेकिन 2 चेन में.

हम [MoreVp 7](https://ethresear.ch/t/more-viable-plasma/2160) के आइडिया पर काम कर रहे हैं. कम शब्दों में कहें, तो MoreVP ने निकास प्राथमिकता, जो "यंगेस्ट इनपुट" प्राथमिकता कहलाता है, की गणना करने का एक नया तरीका पेश किया है. आउटपुट की उम्र के हिसाब से निकास का आदेश देने के बजाय, moreVP यंगेस्ट इनपुट के उम्र के हिसाब से निकास का आदेश देता है. इसका असर यह होता है कि आउटपुट का निकास तब तक सही तरीके से प्रोसेस होंगे जब तक सिर्फ़ वे वैध इनपुट्स से निकलेंगे भले ही वे "अनजान" ट्रांज़ैक्शन के बाद रोके गए ब्लॉक में शामिल क्यों न हों. हम `getAge`को परिभाषित करते हैं जो किसी शामिल किए गए ट्रांज़ैक्शन की उम्र नियत करता है. जैसा कि इसे [न्यूनतम व्यवहार्य प्लाज़्मा 1](https://ethresear.ch/t/minimal-viable-plasma/426) में परिभाषित किया गया है.

```jsx
function getAge(receipt) {
  const { headerNumber, plasmaBlockNum, txindex, oindex } = receipt
  return f(headerNumber, plasmaBlockNum, txindex, oindex) // multiplied with their respective weights
}
```

## निकास से जुड़े परिदृश्य {#exit-scenarios}

आइये बाहर निकलने के परिदृश्यों पर चर्चा जारी रखने से पहले कुछ शब्दावली पेश करते हैं:

- **विथड्रॉवर**: कोई यूज़र जो प्लाज़्मा चेन से बाहर निकलना चाहता हो.
- **कमिटेड ट्रांज़ैक्शन**: एक ऐसा ट्रांज़ैक्शन जिसे पॉलीगॉन चेन ब्लॉक में शामिल किया गया है और रुट चेन पर चेकपॉइंट किया गया है.
- **स्पेंड ट्रांज़ैक्शन**: एक ऐसा ट्रांज़ैक्शन जो यूज़र द्वारा साइन किए गए किसी एक्शन के ज़वाब में यूज़र का टोकन बैलेंस बदल देता है (आने वाले टोकन ट्रांसफ़र को शामिल नहीं करता है). हो सकता है कि यह किसी यूज़र द्वारा शुरू किया गया ट्रांसफ़र, बर्न ट्रांज़ैक्शन वगैरह-वगैरह हो
- **रेफ़रेंस ट्रांज़ैक्शन**: ऐसे ट्रांज़ैक्शन जो किसी खास यूज़र और टोकन के लिए होने वाले निकास ट्रांज़ैक्शन से ठीक पहले हों. जैसा कि हमारे अकाउंट बैलेंस पर आधारित UTXO स्कीम में निर्दिष्ट किया गया है, रेफ़रेंस ट्रांज़ैक्शन के आउटपुट जिस ट्रांज़ैक्शन से बाहर निकलने वाले होते हैं, उसी के इनपुट बन जाते हैं.
- **MoreVP निकास की प्राथमिकता**: किसी खास ट्रांज़ैक्शन के लिए यंगेस्ट इनपुट (रेफ़रेंस ट्रांज़ैक्शन में से) की उम्र. इसका इस्तेमाल अक्सर निकास की प्राथमिकता की गणना करने के लिए किया जाएगा.

### टोकन लिखें {#burn-tokens}

साइडचेन से बाहर निकलने के लिए, कोई यूज़र प्लाज़्मा चेन पर *विथड्रॉ उर्फ़ बर्न टोकन* ट्रांज़ैक्शन लॉन्च करेगा. यह ट्रांज़ैक्शन एक `Withdraw`इवेंट एमिट करेगा.

```jsx
event Withdraw(
    address indexed token,
    address indexed from,
    uint256 amountOrTokenId,
    uint256 input1,
    uint256 output1
);
```

यहाँ `input1`सवालिया टोकन के लिए यूज़र का पिछला बैलेंस दर्शाता है और `output1`साइड चेन पर छोड़े गए टोकन की संख्या को दर्शाता है. यह कंस्ट्रक्शन हमारे अकाउंट-आधारित *UTXO*स्कीम के साथ मेल खाता है. कोई यूज़र मुख्य चेन पर टोकन विथड्रॉ करने के लिए इस विथड्रॉ ट्रांज़ैक्शन की रिसिप्ट देगा. इस रिसिप्ट का जिक्र करते हुए, यूज़र को इन्हें भी मुहैया कराना होगा:

1. साइड चेन ब्लॉक (`receiptsRoot`) में रिसिप्ट शामिल करने का मर्कल सबूत
2. साइड चेन ब्लॉक (`transactionsRoot`) में ट्रांज़ैक्शन शामिल करने का मर्कल सबूत
3. रुट चेन पर चेकपॉइंट में साइड चेन ब्लॉक हेडर शामिल करने का सबूत

```jsx
startExit(withdrawTx, proofOfInclusion /* of the withdrawTx in the checkpoint */) {
  Verify inclusion of withdrawTx in checkpoint using proofOfInclusion
  Verify msg.sender == ecrecover(withdrawTx)

  uint age = getAge(withdrawTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}
```

जब कभी भी कोई यूज़र प्लाज़्मा चेन से बाहर निकलना चाहे, तो उसे साइड चेन पर टोकन बर्न कर देना चाहिए, चेकपॉइंट के लिए इंतज़ार किया जाना चाहिए और फिर चेकपॉइंट किए गए विथड्रॉ ट्रांज़ैक्शन से बाहर निकलने की शुरुआत करनी चाहिए.

### पिछले ERC20/721 transfers the से बाहर करें (MoreVP) {#exit-from-the-last-erc20-721-transfers-morevp}

एक परिदृश्य पर गौर करें, यूज़र ने साइड चेन पर erc20 ट्रांसफ़र किया है. ऑपरेटर ने यूज़र के ट्रांसफ़र से ठीक पहले एक अनजान ट्रांज़ैक्शन जोड़ा है और इस ब्लॉक को चेकपॉइंट करने के लिए वैलिडेटरों के साथ काम किया है. इस परिदृश्य में आमतौर पर, A1 से लेकर A3 तक हमले से जुड़े वाहकों में, जैसा कि ऊपर बताया गया है, खराबी पैदा करने वाले किसी ट्रांज़ैक्शन को शामिल किए बिना यूज़र के पास अपने टोकन को बर्न करने का मौका नहीं हो सकता था और इसलिए रुट चेन पर चेकपॉइंट किए गए पिछले ट्रांज़ैक्शन से बाहर निकलने की शुरुआत करनी पड़ेगी - इस कारण से, एक्ज़िट बर्न करने के अलावे, हमें दूसरे ट्रांसफ़र के साथ-साथ ERC20/721 ट्रांसफ़र जैसे अलग-अलग तरह के ट्रांज़ैक्शनों से निकास में सहायता देनी होगी. हमले से जुड़े इस वाहक को बनाना और 2 परिदृश्यों को अलग करना:

**बाहर जाने वाला ट्रांसफ़र:** मैंने एक यूज़र को कुछ टोकन ट्रांसफ़र किया, हालांकि मैंने गौर किया कि ऑपरेटर ने मेरे ट्रांसफ़र ट्रांज़ैक्शन को शामिल करने से पहले ब्लॉक/चेकपॉइंट में खराबी पैदा करने वाला ट्रांज़ैक्शन शामिल कर दिया. मुझे चेन से बाहर निकलने की शुरुआत करनी होगी. मैं ट्रांसफ़र ट्रांज़ैक्शन से बाहर निकलना शुरु करूँगा. जैसा कि MoreVP में निर्दिष्ट किया गया है, मुझे एक रेफ़रेंस ट्रांज़ैक्शन (*इनपुट UTXO*) मुहैया करना होगा जो निकास की निकास प्राथमिकता को परिभाषित करेगा. इसलिए, मैं एक ऐसे ट्रांज़ैक्शन का जिक्र करूँगा जिसने मेरे टोकन बैलेंस को अपडेट किया और बाहर जाने वाले ट्रांसफ़र ट्रांज़ैक्शन से ठीक पहले हुआ.

```jsx
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the user after the input tx was executed >= tokens being transferred in the exitTx
  Verify msg.sender == ecrecover(exitTx)

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

**आने वाला ट्रांसफ़र:** मैंने गौर किया कि ऑपरेटर ने मेरे आने वाले ट्रांसफ़र ट्रांज़ैक्शन को शामिल करने से पहले ब्लॉक/चेकपॉइंट में एक खराबी पैदा करने वाला ट्रांज़ैक्शन शामिल किया. मैं काउंटर-पार्टी के बैलेंस का जिक्र करते हुए आने वाले ट्रांसफ़र से निकलना शुरू करूँगा - क्योंकि यहाँ *इनपुट UTXO* काउंटर-पार्टी का टोकन बैलेंस है.

```
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the counterparty after the input tx was executed >= tokens being transferred in the exitTx
  Verify input.sender == ecrecover(exitTx) && input.receiver == msg.sender

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

### इन-फ्लाइट transaction an से बाहर हो (MoreVP) {#exit-from-an-in-flight-transaction-morevp}

यह परिदृश्य डेटा की अनुपलब्धता वाले परिदृश्य का सामना करने के लिए बना है. चलिए मानते हैं कि मैंने एक ट्रांज़ैक्शन किया लेकिन मुझे नहीं पता कि डेटा की अनुपलब्धता के कारण ट्रांज़ैक्शन को शामिल किया गया है या नहीं. मैं पिछले चेकपॉइंट किए गए ट्रांज़ैक्शन का जिक्र करके इस इन-फ़्लाइट ट्रांज़ैक्शन से निकलना शुरू कर सकता हूँ. यूज़र को इस बात के लिए सावधान रहना चाहिए कि वे जब भी किसी MoreVP शैली में निकलना शुरू करें तब कोई भी ट्रांज़ैक्शन न करें नहीं तो उन्हें चैलेंज का सामना करना पड़ेगा.

**नोट:** किसी MoreVP जैसे कंस्ट्रक्शन से बाहर निकलते समय यूज़र रेफ़रेंस ट्रांज़ैक्शन, एक्ज़िट ट्रांज़ैक्शन मुहैया करके और एक छोटा `exit bond`लगा कर एक निकलना शुरू कर सकते हैं. किसी भी निकास के लिए, अगर निकास को सफलतापूर्वक चैंलेंज किया जाता है, तो निकासकैंसिल कर दिया जाएगा और निकास बॉन्ड को ज़ब्त कर लिया जाएगा.

## सीमाएँ {#limitations}

1. सबूत का बड़ा आकार: चेकपॉइंट में ट्रांज़ैक्शन को शामिल करने का मर्कल सबूत और ब्लॉक (जिसमें वह ट्रांज़ैक्शन शामिल हो) को शामिल करने का मर्कल सबूत.
2. बड़े पैमाने पर निकास: अगर ऑपरेटर खराबी पैदा करने लगे, तो यूज़र को बड़े पैमाने पर निकास शुरू करना होगा.

विशेष निर्देश अभी शुरुआती स्तर पर है और हम इसमें सुधार करने में या अगर कंस्ट्रक्शन उम्मीद से परे पूरी तरह टूट जाए, तो एक साथ फिर से डिज़ाइन करने में मदद करने से जुड़े किसी भी फ़ीडबैक की सराहना करेंगे. यह कार्यान्वयन हमारे [कॉन्ट्रैक्ट](https://github.com/maticnetwork/contracts) रिपोजिटरी में प्रगति का काम है.