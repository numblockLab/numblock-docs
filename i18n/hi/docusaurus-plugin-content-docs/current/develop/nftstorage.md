---
id: nftstorage
title: NFT मिंट करें
description: NFT.storage और पॉलीगॉन के साथ मिंट करें.
keywords:
  - nft.storage
  - filecoin
  - matic
  - polygon
  - docs
  - mint nfts
image: https://wiki.polygon.technology/img/polygon-wiki.png
---

यह ट्यूटोरियल आपको NFT.Storage के ज़रिये पॉलीगॉन ब्लॉकचेन और IPFS/filecoin स्टोरेज का इस्तेमाल करके NFT मिंट करना सिखाएगा. पॉलीगॉन, एथेरेयम के लिए एक दो स्तर वाला स्केलिंग सोल्यूशन है जिसे अक्सर डेवलपर्स इसकी स्पीड और कम ट्रांज़ैक्शन लागत के अलावा एथेरेयम के EVM के साथ पूरी संगतता बनाए रखने की इसकी क्षमता के कारण चुनते हैं. यह ट्यूटोरियल आपको एक मानकीकृत स्मार्ट कॉन्ट्रैक्ट के निर्माण और डिप्लॉयमेंट के बारे में बताएगा, NFT.Storage API के माध्यम से IPFS और Filecoin पर मेटाडेटा एवं संपत्तियों को स्टोर करेगा और पॉलीगॉन पर अपने वॉलेट में NFT मिंट करेगा.

## परिचय {#introduction}

इस ट्यूटोरियल में हम अपनी मिंट करने की प्रक्रिया के साथ तीन विशेषताओं को पूरा करने का लक्ष्य रखेंगे:

1. लागत और प्रवाह के आधार पर मिंट करने की प्रक्रिया की *स्केलेबिलिटी*. अगर इस्तेमाल करने के मामले लगातार NFT बनाने के लिए लक्षित हों, तो अंतर्निहित तकनीक को मिंट करने के सभी अनुरोधों को संभालने के काबिल होना चाहिए और मिंटिंग सस्ती होनी चाहिए.
2. NFT का *मज़बूत* होना ज़रूरी है, क्योंकि एसेट लंबे समय तक जीवित रह सकता है और इसलिए उन्हें अपने पूरे जीवनकाल के दौरान इस्तेमाल करने योग्य रहने की आवश्यकता होती है.
3. NFT की *अपरिवर्तनीयता* और यह जिन एसेट का यह प्रतिनिधित्व करता है उनके अवांछित परिवर्तनों और दुर्भावनापूर्ण चीज़ों को NFT के प्रतिनिधित्व वाले डिजिटल असेट को बदलने से रोकता है.

[पॉलीगॉन](https://polygon.technology), *स्केलेबिलिटी* के गुण को अपने प्रोटोकॉल और फ्रेमवर्क के साथ संबोधित करता है. ये एथेरेयम और इसकी वर्चुअल मशीन के साथ कम्पैटिबल भी हैं, जो डेवलपर्स को दो ब्लॉकचेन के बीच कोड को स्वतंत्र रूप से स्थानांतरित करने में सक्षम बनाता है. इसी तरह, [NFT.Storage](https://nft.storage) *मज़बूती* के साथ अंतर्निहित [Filecoin](https://filecoin.io) नेटवर्क की गारंटी देता है और *अपरिवर्तनीयता* के साथ IPFS की [सामग्री को संबोधित](https://nftschool.dev/concepts/content-addressing/) करते हुए इस्तेमाल करता है.

इस ट्यूटोरियल में आपको NFT मिंटिंग प्रक्रिया का एक ओवरव्यू मिलेगा, जानें कि NFT.Storage के साथ डिजिटल असेट को कैसे स्टोर किया जाए और इस असेट को पॉलीगॉन पर अपने NFT को मिंट करने के लिए कैसे इस्तेमाल किया जाए.

## आवश्यक शर्तें {#prerequisites}

NFT के बारे में सामान्य ज्ञान, आपको इसके बैकग्राउंड और संदर्भ के बारे में बताएगा. [NFT स्कूल NFT की बुनियादी बातों के साथ](https://nftschool.dev/concepts/non-fungible-tokens/) उन्नत विषयों को कवर करता है और इसमें और भी ट्यूटोरियल हैं.

इस ट्यूटोरियल में पाए गए कोड को टेस्ट और रन करने के लिए, आपको एक वर्किंग [Node.js इंस्टालेशन](https://nodejs.org/en/download/package-manager/) की जरूरत होगी.

आपको मैटिक टोकन की एक छोटी राशि के साथ मुंबई टेस्टनेट पर पॉलीगॉन वॉलेट की भी ज़रूरत होगी. शुरू करने के लिए नीचे दिए निर्देशों का पालन करें:

1. मेटामास्क को **[](https://metamask.io/)डाउनलोड और इंस्टॉल करें**. मेटामास्क एक क्रिप्टो वॉलेट और ब्लॉकचेन ऐप्स के लिए गेटवे है. यह इस्तेमाल करने में बहुत आसान है और कई स्टेप्स जैसे पॉलीगॉन वॉलेट को सेट करने को और सरल बना देता है.
2. **मेटामास्क को पॉलीगॉन के [मुंबई टेस्टनेट](https://docs.polygon.technology/docs/develop/metamask/overview) से कनेक्ट करें** और इसे ड्रॉपडाउन मेन्यू में से चुनें. हम पॉलीगॉन के टेस्टनेट को इस्तेमाल करके अपने NFT को मिंट करेंगे, क्योंकि यह मुफ़्त है.
3. अपने वॉलेट में **मैटिक टोकन को पाने के लिए** [फ़ॉसेट](https://faucet.polygon.technology/) का इस्तेमाल करें. मुंबई टेस्टनेट को चुनें और मेटामास्क से फ़ॉर्म में अपने वॉलेट का पता पेस्ट करें. एक NFT को मिंट करने के लिए, हमें मैटिक की एक छोटी सी रकम का भुगतान करने की आवश्यकता है जो ब्लॉकचेन में नए ट्रांज़ैक्शन जोड़ने के लिए माइनर्स द्वारा काम करने जैसे NFT को मिंट करना या नए स्मार्ट कॉन्ट्रैक्ट बनाने के लिए ली जाने वाली एक फ़ीस है.
4. ऊपरी दाएँ कोने से तीन बिंदुओं पर क्लिक करके और 'अकाउंट विवरण' को चुनकर मेटामास्क से **अपनी निजी की को कॉपी करें**. अपनी निजी की को एक्सपोर्ट करने के लिए आपको सबसे नीचे एक बटन मिलेगा. इसे क्लिक करें और पूछे जाने पर अपना पासवर्ड डालें. अब आप निजी की को एक टेक्स्ट फ़ाइल में कॉपी और पेस्ट कर सकते हैं. हम इसे बाद में ब्लॉकचेन के साथ इंटरैक्ट करते समय ट्यूटोरियल में इस्तेमाल करेंगे.

अंत में, आपको एक टेक्स्ट या कोड एडिटर की आवश्यकता होगी. और अधिक सुविधा के लिए, एक ऐसे एडिटर को चुनें जो JavaScript और सॉलिडिटी दोनों भाषाओं को सपोर्ट करता हो. [विज़ुअल स्टूडियो कोड](https://code.visualstudio.com), [सॉलिडिटी](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity) एक्सटेंशन के साथ सक्षम होने पर एक अच्छा विकल्प हो सकता है.

## तैयारी {#preparation}

### NFT.storage के लिए एक API की लें {#get-an-api-key-for-nft-storage}

NFT.Storage को इस्तेमाल करने के लिए आपको API की आवश्यक होगी. सबसे पहले, [NFT.Storage पर अपने ईमेल पते के साथ लॉग इन करने के लिए जाएँ](https://nft.storage/login/). आपको एक मैजिक लिंक के साथ एक ईमेल मिलेगा जिससे आप साइन इन कर पाएँगे -- इसके लिए किसी पासवर्ड की ज़रूरत नहीं होगी. आपके सफलतापूर्वक लॉग इन करने के बाद, नेविगेशन बार के ज़रिए API कीज़ पर जाएँ. आपको **नई की** बनाने के लिए एक बटन मिलेगा. जैसे ही API की के नाम के लिए पूछा जाए, आप स्वतंत्र रूप से एक नाम चुनें या आप "पॉलीगॉन + NFT.Storage" का इस्तेमाल भी कर सकते हैं. अब आप की कॉलम की सामग्री को कॉपी कर सकते हैं या बाद में दोबारा संदर्भ के लिए NFT.Storage ट्यूटोरियल में जा सकते हैं.

### अपने वर्कस्पेस को सेट अप करें {#set-up-your-workspace}

एक नया खाली फ़ोल्डर बनाएँ जिसे हम ट्यूटोरियल के लिए अपने वर्कस्पेस के रूप में इस्तेमाल कर सकते हैं. अपने फ़ाइल सिस्टम पर स्वतंत्र रूप से किसी भी नाम और स्थान को चुनें. एक टर्मिनल खोलें और बनाए गए नए फ़ोल्डर पर नेविगेट करें.

इसके बाद, हम नीचे दी गई Node.js निर्भरताओं को इंस्टॉल करेंगे:

- **Hardhat और Hardhat-Ethers**, एथेरेयम (और एथेरेयम कॉम्पैटिबल ब्लॉकचेन जैसे पॉलीगॉन) के लिए एक विकास का वातावरण है.
- **OpenZepPelin**, स्मार्ट कॉन्ट्रैक्ट का एक संग्रह है जिसमें मानकीकृत विशेषता वाले, NFT पर आधारित कॉन्ट्रैक्ट होते हैं.
- **NFT.Storage**, एक लाइब्रेरी है जो NFT.Storage API से कनेक्ट कराती है.
- **Dotenv**, कॉन्फ़िगरेशन के लिए वातावरण की फ़ाइलों को संभालने वाली एक लाइब्रेरी है  (जैसे ,स्क्रिप्ट में निजी की को इंजेक्ट करने आदि).

सभी निर्भरताओं को एक साथ इंस्टॉल करने के लिए नीचे दी गई कमांड का इस्तेमाल करें:

```bash
npm install hardhat @openzeppelin/contracts nft.storage dotenv @nomiclabs/hardhat-ethers
```

हार्डहैट को वर्तमान फ़ोल्डर में शुरू करने की आवश्यकता है. इसकी शुरुआत करने के लिए, यह एक्जीक्यूट करें:

```bash
npx hardhat
```

जब प्रांप्ट किया जाता है, तो **खाली hardhat.config.js. बनाएँ** आपके कंसोल का आउटपुट इस तरह का दिखना चाहिए:

```bash
✔ What do you want to do? · Create an empty hardhat.config.js
✨ Config file created ✨
```

हम हार्डहैट कॉन्फ़िगरेशन की फ़ाइल `hardhat.config.js` में कुछ संशोधन करेंगे, ताकि यह पॉलीगॉन मुंबई टेस्ट नेटवर्क को सपोर्ट कर सके. अंतिम स्टेप में बनाए गए `hardhat.config.js` को खोलें. कृपया नोट करें कि हम आपके पॉलीगॉन वॉलेट की निजी की को एक वातावरण की फ़ाइल से लोड कर रहे हैं और यह वातावरण की फ़ाइल सुरक्षित रखी जानी चाहिए. आप आवश्यकता के अनुसार दूसरे rpc [लिंक](https://docs.polygon.technology/docs/develop/network-details/network) का इस्तेमाल भी कर सकते हैं.

```js
/**
* @type import('hardhat/config').HardhatUserConfig
*/
require("@nomiclabs/hardhat-ethers");
require('dotenv').config();
const { PRIVATE_KEY } = process.env;
module.exports = {
  defaultNetwork: "PolygonMumbai",
  networks: {
    hardhat: {
    },
    PolygonMumbai : {
      url: "https://rpc-mumbai.maticvigil.com",
      accounts: [PRIVATE_KEY]
    }
  },
  solidity: {
    version: "0.8.12",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
}
```

एक नई फ़ाइल तैयार करें `.env`जो NFT.Storage और आपके पॉलीगॉन वॉलेट निजी की के लिए आपकी API की को पकड़ लेगी. `.env`फ़ाइल की सामग्री को कुछ इस प्रकार देखना चाहिए:

```bash
PRIVATE_KEY="Your Private Key"
NFT_STORAGE_API_KEY="Your Api Key"
```

तैयारी के दौरान बनाए गए API की के साथ प्लेसहोल्डर और पॉलीगॉन वॉलेट को निजी की के साथ बदलें.

अपने प्रोजेक्ट को संगठित बनाए रखने के लिए, हम तीन नए फ़ोल्डर बनाएँगे:

1. सॉलिडिटी में लिखे गए पॉलीगॉन कॉन्ट्रैक्ट के लिए, `contracts`.
2. `assets` जिसमें डिजिटल असेट समाहित हैं, हम एक NFT के रूप में मिंट करेंगे.
3. तैयारी और मिंट की प्रक्रिया को चलाने के लिए `scripts` मददगारों के रूप में हैं.

निम्नलिखित कमांड को चलाएँ:

```bash
mkdir contracts assets scripts
```

अंत में, हम `assets` फ़ोल्डर में एक इमेज जोड़ेंगे. यह इमेज हमारी कलाकृति होगी, जिसे हम NFT.Storage पर अपलोड करेंगे और पॉलीगॉन पर मिंट करेंगे. अभी हम इसे `MyExampleNFT.png` नाम देंगे. अगर आपके पास अभी कोई अच्छी कला तैयार नहीं है, तो आप [एक सरल पैटर्न को डाउनलोड कर सकते हैं](https://ipfs.io/ipfs/bafkreiawxb4aji744637trok275odl33ioiijsvvahnat2kw5va3at45mu).

## आपके NFT को मिंट कर रहा है {#minting-your-nft}

### NFT.Storage के साथ असेट डेटा को स्टोर किया जा रहा है {#storing-asset-data-with-nft-storage}

हम अपने डिजिटल असेट और मेटाडेटा को स्टोर करने के लिए NFT.Storage का इस्तेमाल करेंगे. NFT.Storage आपके डिजिटल असेट को Filecoin और IPFS पर स्वचालित रूप से अपलोड करके अपरिवर्तनीयता और मज़बूती की गारंटी देता है. IPFS और Filecoin, अपरिवर्तनीयता को संदर्भित करने के लिए सामग्री की पहचान करने वालों (CID) पर काम करते हैं. IPFS अपने जगहों की नक़ल करने वाले कैशिंग और Filecoin के साथ तेजी से पुनर्प्राप्ति की सुविधा प्रदान करेगा, जो प्रोत्साहित करने वाले स्टोरेज प्रदाताओं के साथ मज़बूती की गारंटी देता है.

`scripts` डायरेक्टरी के नीचे, `store-asset.mjs` नामक स्क्रिप्ट बनाएँ. सामग्री नीचे सूचीबद्ध की गई है:

```js
import { NFTStorage, File } from "nft.storage"
import fs from 'fs'
import dotenv from 'dotenv'
dotenv.config()

const { NFT_STORAGE_API_KEY } = process.env

async function storeAsset() {
   const client = new NFTStorage({ token: NFT_STORAGE_API_KEY })
   const metadata = await client.store({
       name: 'ExampleNFT',
       description: 'My ExampleNFT is an awesome artwork!',
       image: new File(
           [await fs.promises.readFile('assets/MyExampleNFT.png')],
           'MyExampleNFT.png',
           { type: 'image/png' }
       ),
   })
   console.log("Metadata stored on Filecoin and IPFS with URL:", metadata.url)
}

storeAsset()
   .then(() => process.exit(0))
   .catch((error) => {
       console.error(error);
       process.exit(1);
   });
```

स्क्रिप्ट का मुख्य भाग `storeAsset` फ़ंक्शन है. यह NFT.Storage से जुड़ने वाला एक नया क्लाइंट बनाता है जो पहले बनाए गए API की को इस्तेमाल करके बनाया गया है. इसके बाद हम मेटाडेटा को पेश करते हैं जिसमें नाम, वर्णन और इमेज शामिल हैं. नोट करें कि हम `assets` डायरेक्टरी के फ़ाइल सिस्टम से सीधे NFT असेट को पढ़ रहे हैं. फंक्शन के अंत में हम मेटाडेटा URL को प्रिंट करेंगे ताकि, हम इसे पॉलीगॉन पर NFT बनाने के दौरान बाद में इस्तेमाल कर सकें.

स्क्रिप्ट को सेट करने के बाद, आप इसे रन करके चला सकते हैं:

```bash
node scripts/store-asset.mjs
```

आपका आउटपुट नीचे सूचीबद्ध तरीके से दिखाई देना चाहिए, जहाँ अभी आपके द्वारा संग्रहित की गई कला के लिए, `HASH` CID है.

```bash
Metadata stored on Filecoin/IPFS at URL: ipfs://HASH/metadata.json
```

### पॉलीगॉन पर आपका NFT बनाया जा रहा है {#creating-your-nft-on-polygon}

#### मिंट करने के लिए स्मार्ट कॉन्ट्रैक्ट बनाएँ {#create-the-smart-contract-for-minting}

पहले, हम एक स्मार्ट कॉन्ट्रैक्ट बनाएँगे, जो NFT को मिंट करने के लिए इस्तेमाल किया जाएगा. चूँकि पॉलीगॉन एथेरेयम के साथ कॉम्पैटिबल है, हम [सॉलिडिटी](https://soliditylang.org) में स्मार्ट कॉन्ट्रैक्ट लिखेंगे. हमारे NFT स्मार्ट कॉन्ट्रैक्ट के लिए `ExampleNFT.sol` नामक एक नई फ़ाइल `contracts` डायरेक्टरी के अंदर बनाएँ. आप नीचे की सूची से कोड को कॉपी कर सकते हैं:

```solidity
// Contract based on https://docs.openzeppelin.com/contracts/4.x/erc721
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract ExampleNFT is ERC721URIStorage, Ownable {
   using Counters for Counters.Counter;
   Counters.Counter private _tokenIds;

   constructor() ERC721("NFT", "ENFT") {}

   function mintNFT(address recipient, string memory tokenURI)
       public onlyOwner
       returns (uint256)
   {
       _tokenIds.increment();

       uint256 newItemId = _tokenIds.current();
       _mint(recipient, newItemId);
       _setTokenURI(newItemId, tokenURI);

       return newItemId;
   }
}
```

एक वैध NFT होने के लिए, आपके स्मार्ट कॉन्ट्रैक्ट को [ERC-721 मानक](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/) के सभी तरीकों को लागू करना चाहिए. हम [OpenZeppelin](https://openzeppelin.com) लाइब्रेरी के लागू करने को इस्तेमाल करते हैं, जो पहले से ही बुनियादी कार्यवाहियों का एक सेट प्रदान करता है और मानक का पालन करता है.

हमारे स्मार्ट कॉन्ट्रैक्ट के शीर्ष पर, हम तीन OpenZeppelin स्मार्ट कॉन्ट्रैक्ट क्लासों को इम्पोर्ट करते हैं:

1. `\@openzeppelin/contracts/token/ERC721/ERC721.sol` में ERC-721 मानक के बुनियादी तरीकों को लागू करना शामिल है, जो हमारे NFT स्मार्ट कॉन्ट्रैक्ट को विरासत में मिलेंगे. हम `ERC721URIStorage,` को इस्तेमाल करते हैं जो न केवल एसेट को, बल्कि मेटाडेटा को एक JSON फ़ाइल ऑफ चेन के रूप में स्टोर करने के लिए एक एक्सटेंशन है. कॉन्ट्रैक्ट की तरह, इस JSON फ़ाइल को ERC-721 का पालन करने की आवश्यकता है.

2. `\@openzeppelin/contracts/utils/Counters.sol` ऐसे काउंटर प्रदान करता है जिन्हें केवल एक के द्वारा बढ़ाया या घटाया जा सकता है. हमारा स्मार्ट कॉन्ट्रैक्ट एक काउंटर का इस्तेमाल करता है जो मिंट किए गए NFT की कुल संख्या को ट्रैक करने और हमारे नए NFT पर यूनिक ID सेट करता है.

3. `\@openzeppelin/contracts/access/Ownable.sol`, हमारे स्मार्ट कॉन्ट्रैक्ट पर एक्सेस के नियंत्रण को सेट करता है, ताकि केवल स्मार्ट कॉन्ट्रैक्ट के स्वामी (आप) ही NFT को मिंट कर सकें.

हमारे इम्पोर्ट के बयानों के बाद, हमारे पास अपने कस्टम NFT स्मार्ट कॉन्ट्रैक्ट हैं, जिसमें एक काउंटर है, एक कंस्ट्रक्टर और वास्तविक रूप से NFT को मिंट करने का एक तरीका शामिल है. ज़्यादातर मेहनत OpenZeppelin से विरासत मिलने वाले बुनियादी कॉन्ट्रैक्ट द्वारा की जाती है, जो उन ज़्यादातर तरीकों को लागू करता है जो हमें एक NFT को ERC-721 मानक को ध्यान में रखते हुए बनाने की आवश्यकता होती है.

काउंटर, मिंट किए गए कुल NFT की संख्या को ट्रैक करता है, जिसे मिंट करने के तरीके में NFT के एक यूनिक पहचानकर्ता के रूप में इस्तेमाल किया जाता है.

कंस्ट्रक्टर में, हम स्मार्ट कॉन्ट्रैक्ट और सिंबल (वॉलेट में प्रतिनिधित्व करने वाले) के नाम के लिए दो स्ट्रिंग वाली आर्ग्युमेंट से गुज़रते हैं. आप उन्हें अपनी पसंद के अनुसार बदल सकते हैं.

आखिरकार, हमारे पास अपना तरीका `mintNFT` है - जो हमें सच में NFT मिंट करने की अनुमति देता है. यह तरीका, `onlyOwner` को सेट करता है ताकि यह सुनिश्चित किया जा सके कि इसे स्मार्ट कॉन्ट्रैक्ट के स्वामी द्वारा ही एक्सज़ीक्यूट किया जा सके.

`address recipient`पहले में NFT प्राप्त करने वाले पता को निर्दिष्ट करता है.

`string memory tokenURI` एक URL है जिसे एक JSON डॉक्यूमेंट में हल किया जाना चाहिए, जो NFT के मेटाडेटा को वर्णित करता है. हमारे मामले में यह पहले से ही NFT.Storage में संग्रहीत है. हम इस तरीके को अपनाने के दौरान मेटाडेटा JSON फ़ाइल पर वापस लौटने के लिए IPFS लिंक को इस्तेमाल कर सकते हैं.

तरीके के भीतर, हम अपने NFT के लिए एक नए यूनिक पहचानकर्ता प्राप्त करने के लिए काउंटर को बढ़ाते हैं. फिर हम OpenZeppelin से बुनियादी कॉन्ट्रैक्ट द्वारा प्रदान किए गए तरीकों को कॉल करते हैं ताकि नए बने पहचानकर्ता के साथ प्राप्तकर्ता के लिए NFT को मिंट किया जा सके और मेटाडेटा का URI सेट किया जा सके. यह तरीका एग्जीक्यूशन के बाद यूनिक पहचानकर्ता को वापस लौटा देता है.

#### पॉलीगॉन में स्मार्ट कॉन्ट्रैक्ट को डिप्लॉय करें {#deploy-the-smart-contract-to-polygon}

अब, समय आ गया है कि अपने स्मार्ट कॉन्ट्रैक्ट को पॉलीगॉन में डिप्लॉय करें. एक `deploy-contract.mjs` नामक फ़ाइल को `scripts` डायरेक्टरी के अंदर बनाएँ. नीचे की सूची की सामग्री को उस फ़ाइल में कॉपी करें और इसे सेव करें.

```js
async function deployContract() {
 const ExampleNFT = await ethers.getContractFactory("ExampleNFT")
 const exampleNFT = await ExampleNFT.deploy()
 await exampleNFT.deployed()
 // This solves the bug in Mumbai network where the contract address is not the real one
 const txHash = exampleNFT.deployTransaction.hash
 const txReceipt = await ethers.provider.waitForTransaction(txHash)
 const contractAddress = txReceipt.contractAddress
 console.log("Contract deployed to address:", contractAddress)
}

deployContract()
 .then(() => process.exit(0))
 .catch((error) => {
   console.error(error);
   process.exit(1);
 });
```

हार्डहैट लाइब्रेरी द्वारा प्रदान किए गए हेल्पर फंक्शन के साथ कॉन्ट्रैक्ट को डिप्लॉय किया जाता है. पहले, दी गई फैक्ट्री के साथ पिछले स्टेप में हमने जो स्मार्ट कॉन्ट्रैक्ट बनाए थे उन्हें प्राप्त करते हैं. फिर हम इसे संबंधित तरीके को कॉल करके डिप्लॉय करते हैं और डिप्लॉयमेंट के पूरा होने का इंतज़ार करते हैं. टेस्टनेट वातावरण में सही पते को पाने के लिए बताए गए कोड के नीचे कुछ और लाइनें हैं. फ़ाइल `mjs`सहेजें.

स्क्रिप्ट को निम्नलिखित कमांड के साथ एक्जीक्यूट करें

```bash
npx hardhat run scripts/deploy-contract.mjs --network PolygonMumbai
```

अगर सब कुछ सही रहता है तो आप निम्नलिखित आउटपुट देखेंगे:

```bash
Contract deployed to address: 0x{YOUR_CONTRACT_ADDRESS}
```

नोट करें कि आपको मिंट करने के स्टेप में कॉन्ट्रैक्ट का पता प्रिंट करने की आवश्यकता होगी. आप इसे एक अलग टेक्स्ट फ़ाइल में कॉपी और पेस्ट कर सकते हैं और इसे बाद के लिए सेव कर सकते हैं. यह आवश्यक है ताकि मिंटिंग स्क्रिप्ट उस खास कॉन्ट्रैक्ट के मिंटिंग के तरीके को कॉल कर सकती है.

#### पॉलीगॉन पर NFT को मिंट करना {#minting-the-nft-on-polygon}

NFT को मिंट करना अब केवल उस कॉन्ट्रैक्ट को कॉल करना है जिसे हमने अभी पॉलीगॉन में डिप्लॉय किया है. `scripts`डायरेक्टरी के अंदर `mint-nft.mjs` नामक एक नई फ़ाइल बनाएँ और नीचे दी गई सूची से इस कोड को कॉपी करें:

```bash
const CONTRACT_ADDRESS = "0x00"
const META_DATA_URL = "ipfs://XX"

async function mintNFT(contractAddress, metaDataURL) {
   const ExampleNFT = await ethers.getContractFactory("ExampleNFT")
   const [owner] = await ethers.getSigners()
   await ExampleNFT.attach(contractAddress).mintNFT(owner.address, metaDataURL)
   console.log("NFT minted to: ", owner.address)
}

mintNFT(CONTRACT_ADDRESS, META_DATA_URL)
   .then(() => process.exit(0))
   .catch((error) => {
       console.error(error);
       process.exit(1);
   });
```

पहले के डिप्लॉयमेंट से अपना **कॉन्ट्रैक्ट पता** और NFT.Storage के साथ एसेट संग्रहित करते समय लौटाए गए **मेटाडेटा URL** को सम्मिलित करने के लिए पहली दो लाइनों को एडिट करें. बाकी की स्क्रिप्ट आपके स्मार्ट कॉन्ट्रैक्ट के लिए कॉल को NFT के होने वाले स्वामी के रूप में और IPFS पर संग्रहीत मेटाडेटा के सूचक के रूप में आपको सेट करती है.

इसके बाद स्क्रिप्ट को रन करें:

```bash
npx hardhat run scripts/mint-nft.mjs --network PolygonMumbai
```

आप निम्नलिखित आउटपुट देखने की उम्मीद कर सकते हैं:

```bash
NFT minted to: 0x<YOUR_WALLET_ADDRESS>
```

इस ट्यूटोरियल से सैंपल कोड की तलाश करें? आप इसे polygon-nft.storage-demo [लिंक](https://github.com/itsPiyushMaheshwari/Polygon-nft.storage-demo) के Github repo में पा सकते हैं.

## निष्कर्ष {#conclusion}

इस ट्यूटोरियल में, हमने जाना कि कैसे पॉलीगॉन और NFT.Storage के साथ NFT को शुरू से अंत तक मिंट किया जाए. यह तकनीक संयोजन के परिणामस्वरूप उचित विकेंद्रीकरण और *स्केलेबिलिटी* *मज़बूती*, एवं *अपरिवर्तनीयता* की गारंटी देती है.

हमने अपनी ज़रूरतों के लिए अपने NFT को मिंट करने के लिए कस्टम स्मार्ट कॉन्ट्रैक्ट को डिप्लॉय किया है. इस ट्यूटोरियल के लिए, हमने ERC-721 मानक के आधार पर एक सरल उदाहरण को इस्तेमाल किया है. हालाँकि, आप अपने NFT के जीवन चक्र को नियंत्रित करने वाले जटिल लॉजिक को भी परिभाषित कर सकते हैं. उपयोग के अधिक जटिल मामलों के लिए, उत्तराधिकारी मानक [ERC-1155](https://ethereum.org/en/developers/docs/standards/tokens/erc-1155/) शुरू करने के लिए एक अच्छी जगह है. OpenZeppelin, लाइब्रेरी जिसे हमने अपने ट्यूटोरियल में इस्तेमाल किया है, एक [कॉन्ट्रैक्ट विज़र्ड](https://docs.openzeppelin.com/contracts/4.x/wizard) ऑफ़र करती है जो NFT कॉन्ट्रैक्ट बनाने में मदद करती है.

NFT के मूल्यवान चरण की शुरुआत में सफल मिंटिंग को देखा जा सकता है. तब NFT का इस्तेमाल स्वामित्व को साबित करने के लिए किया जा सकता है और इसे दूसरे यूज़र्स को स्थानांतरित किया जा सकता है. NFT को स्थानांतरित करने के कारणों में [OpenSea](https://opensea.io), जैसे NFT के बाज़ारों में से एक पर एक सफल बिक्री या NFT आधारित गेम में एक आइटम को प्राप्त करने जैसे विभिन्न प्रकार के आयोजन शामिल हो सकते हैं NFT के लिए अच्छी संभावनाओं की खोज करना निश्चित रूप से एक रोमांचक अगला स्टेप है.

अगर आप NFT के साथ अपनी NFT परियोजना को बनाने में मदद करना चाहते हैं, तो हम आपको [डिस्कॉर्ड](https://discord.gg/Z4H6tdECb9) और [स्लैक](https://filecoinproject.slack.com/archives/C021JJRH26B) पर `#nft-storage`चैनल में शामिल होने के लिए प्रोत्साहित करते हैं.
