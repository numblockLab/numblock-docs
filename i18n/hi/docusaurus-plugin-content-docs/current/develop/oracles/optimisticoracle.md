---
id: optimisticoracle
title: UMA का ऑप्टिमिस्टिक ऑरेकल
sidebar_label: UMA
description: UMA, UMA's Oracle कॉन्ट्रैक्ट को जल्द से जल्द अनुरोध करने और किसी भी प्रकार के डेटा को प्राप्त करने की अनुमति देता है.
keywords:   
  - wiki
  - polygon
  - oracle
  - UMA
  - Optimistic Oracle
image: https://wiki.polygon.technology/img/polygon-wiki.png
---

UMA, Optimistic Oracle कॉन्ट्रैक्ट को जल्द से जल्द अनुरोध करने और किसी भी तरह के डेटा को प्राप्त करने की अनुमति देता है. UMA's  की दैनिकी सिस्टम दो कोर घटकों से शामिल है:

1. ऑप्टिमिस्टिक ऑरेकल
2. डेटा वेरिफ़िकेशन मैकेनिज्म (DVM)

## ऑप्टिमिस्टिक ऑरेकल {#optimistic-oracle}

UMA, **Optimistic Oracle** कॉन्ट्रैक्ट को जल्द से जल्द अनुरोध करने और कीमत की जानकारी प्राप्त करने की अनुमति देता है. Optimistic Oracle कॉन्ट्रैक्ट्स के बीच एक सामान्यीकृत एस्केलेशन गेम के रूप में काम करता है जो कि एक कीमत अनुरोध और UMA, के विवाद रिजोल्यूशन सिस्टम को डेटा वेरिफिकेशन मैकेनिज्म (डीवीएम) के रूप में जाना जाता है.

प्रस्तावित क़ीमतों के विवादित होने की स्थिति के अलावा इन्हें ऑप्टिमिस्टिक ऑरेकल द्वारा DVM को नहीं भेजा जाएगा. इससे कॉन्ट्रैक्ट को ऑन-चेन की परिसंपत्ति की कीमत लिखे बिना समय की किसी पूर्व निर्धारित लंबाई के भीतर कीमत की जानकारी प्राप्त करने में सक्षम होता है.

## डेटा वेरिफ़िकेशन मैकेनिज्म (DVM) {#data-verification-mechanism-dvm}

एक विवाद किए जाने की स्थिति में DVM को अनुरोध भेजा जाता है. UMA पर बने सभी कॉन्ट्रैक्ट विवादों को हल करने के लिए DVM को बैकस्टॉप के रूप में इस्तेमाल करते हैं. डीवीएम को भेजे गए विवादों को UMA टोकनहोल्डर द्वारा निर्धारित समय पर किसी असेट की क़ीमत वोट करने के 48 घंटे बाद हल किया जाएगा. UMA पर कॉन्ट्रैक्ट को तब तक ऑप्टिमिस्टिक ऑरेकल को इस्तेमाल करने की ज़रूरत नहीं है, जब तक उसे 48 घंटे से ज़्यादा पहले एक असेट की क़ीमत की आवश्यकता नहीं होती.

डेटा वेरिफ़िकेशन मैकेनिज्म (DVM), UMA प्रोटोकॉल पर बने कॉन्ट्रैक्ट के लिए विवाद हल करने वाली सेवा है. DVM शक्तिशाली है क्योंकि यह मानवीय फ़ैसले लेने वाले एलिमेंट को शामिल करता है ताकि अस्थिरता वाले बाज़ारों में समस्याएँ खड़ी होने पर कॉन्ट्रैक्ट को सही और सुरक्षित तरीके से प्रबंधित करना सुनिश्चित किया जा सके.

## ऑप्टिमिस्टिक ऑरेकल इंटरफ़ेस {#optimistic-oracle-interface}

ऑप्टिमिस्टिक ऑरेकल को वित्तीय कॉन्ट्रैक्ट या किसी तीसरे पक्ष द्वारा कीमतों को जानने के लिए इस्तेमाल किया जाता है. एक बार क़ीमत के लिए अनुरोध किये जाने पर कोई भी इसके जवाब में क़ीमत का प्रस्ताव रख सकता है. एक बार प्रस्तावित होने के बाद, क़ीमत अपनी लाइवनेस अवधि से गुज़रती है जहाँ कोई भी प्रस्तावित क़ीमत पर विवाद खड़ा कर सकता है और विवादित क़ीमत को सेटलमेंट के लिए UMA के DVM को भेज सकता है.

:::info

इस भाग में बताया गया है कि विभिन्न प्रतिभागी कैसे ऑप्टिमिस्टिक ऑरेकल के साथ इंटरैक्ट कर सकते हैं. सबसे ज़्यादा अपडेटेड मेननेट को देखने के लिए, kovan या ऑप्टिमिस्टिक ऑरेकल कॉन्ट्रैक्ट का L2 डिप्लॉयमेंट करने के लिए [प्रोडक्शन के पतों](https://docs.umaproject.org/dev-ref/addresses) का संदर्भ लें.

:::

बारह तरीकों से ऑप्टिमिस्टिक ऑरेकल इंटरफ़ेस को बनाया जाता है.
- `requestPrice`
- `proposePrice`
- `disputePrice`
- `settle`
- `hasPrice`
- `getRequest`
- `settleAndGetPrice`
- `setBond`
- `setCustomLiveness`
- `setRefundOnDispute`
- `proposePriceFor`
- `disputePriceFor`

### क़ीमत का अनुरोध {#requestprice}

एक नई क़ीमत के लिए अनुरोध करता है. यह अवश्य ही एक रजिस्टर्ड क़ीमत पहचानने वाला होना चाहिए. नोट करें कि UMA सिस्टम में रजिस्टर्ड ज़्यादातर कॉन्ट्रैक्ट द्वारा इसे ऑटोमेटिकली कॉल किया जाता है, लेकिन इसे किसी के भी द्वारा किसी रजिस्टर्ड क़ीमत पहचानने वाले के लिए कॉल किया जा सकता है. उदाहरण के लिए, एक्सपायर होने वाली मल्टीपार्टी (EMP) कॉन्ट्रैक्ट इस तरीके से कॉल करते हैं जब इसके `expire` तरीके को कॉल किया जाता है.

पैरामीटर्स:
- `identifier`: क़ीमत के पहचानकर्ता को अनुरोध किया जा रहा है.
- `timestamp`: क़ीमत के टाइमस्टैम्प को अनुरोध किया जा रहा है.
- `ancillaryData`: अतिरिक्त args का प्रतिनिधित्व करने वाले सहायक डेटा को क़ीमत के अनुरोध से पास किया जा रहा है.
- `currency`: रिवॉर्ड और फ़ीस के भुगतान के लिए ERC20 टोकन का इस्तेमाल किया गया है. DVM के साथ इस्तेमाल के लिए इसकी स्वीकृति अवश्य मिलनी चाहिए.
- `reward`: एक सफल प्रस्ताव भेजने वाले को दिया जाने वाला रिवॉर्ड. कॉलर द्वारा भुगतान किया जाएगा. नोट करें: यह 0 भी हो सकता है.

### प्रस्तावित क़ीमत {#proposeprice}

पहले से मौजूद क़ीमत अनुरोध के लिए प्राइस वैल्यू प्रस्तावित करता है.

पैरामीटर्स:
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.
- `proposedPrice`: प्रस्तावित की जा रही क़ीमत.

### विवादित क़ीमत {#disputeprice}

एक सक्रिय प्रस्ताव के साथ पहले से मौजूद अनुरोध के लिए प्राइस वैल्यू पर विवाद करता है.

पैरामीटर्स:
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### सेटल करना {#settle}

एक बकाया क़ीमत के अनुरोध को सेटल करने के प्रयास. अगर इसका निपटारा नहीं हो तो वापस आ जाएगा.

पैरामीटर्स:
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### hasPrice {#hasprice}

जाँच करता है कि एक दिए गए अनुरोध का समाधान किया गया है या उसे सेटल किया गया है (जैसे कि ऑप्टिमिस्टिक ऑरेकल की एक क़ीमत है).

पैरामीटर्स:
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### getRequest {#getrequest}

मिलता है वर्तमान डेटा स्ट्रक्चर जिसमें एक क़ीमत अनुरोध की सारी जानकारी मौजूद होती है.

पैरामीटर्स:
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### settleAndGetPrice {#settleandgetprice}

एक कॉलर द्वारा पहले अनुरोध की गई क़ीमत को दोबारा प्राप्त करता है. अगर अनुरोध सेटल नहीं होता है या सेटल करने योग्य नहीं है तो वापस भेज देता है. नोट करें: यह तरीका दिखता नहीं है ताकि यह कॉल वास्तव में अगर अनुरोध सेटल नहीं किया गया है तो उसे सेटल कर सकती है.

पैरामीटर्स:
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### setBond {#setbond}

प्रस्तावित बॉन्ड को उससे जुड़ी क़ीमत के अनुरोध के साथ सेट करें.

पैरामीटर्स:
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.
- `bond`: कस्टम बॉन्ड की रकम को सेट करें.

### setCustomLiveness {#setcustomliveness}

अनुरोध के लिए कस्टम लाइवनेस वैल्यू को सेट करता है. लाइवनेस, समय की वो अवधि है जिसके लिए एक प्रस्ताव को अवश्य ही अपने आप हल होने का इंतज़ार करना होता है.

पैरामीटर्स:
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.
- `customLiveness`: नया कस्टम लाइवनेस.

### setRefundOnDispute {#setrefundondispute}

अगर प्रस्ताव विवादित है तो रिवॉर्ड को रिफंड करने के लिए अनुरोध को सेट करता है. इससे विवाद के कारण देरी होने की स्थिति में कॉल करने वाले के लिए "हेज" प्रदान करने में मदद मिल सकती है. नोट करें: एक विवाद होने की स्थिति में भी विजेता को दूसरे का बॉन्ड मिलता है, इसलिए रिवॉर्ड के रिफ़ंड होने पर भी लाभ कमाया जा सकता है.

पैरामीटर्स:
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### disputePriceFor {#disputepricefor}

किसी दूसरे के पते की ओर से एक सक्रिय प्रस्ताव के साथ क़ीमत के एक अनुरोध पर विवाद करता है. नोट करें: इस विवाद से आने वाले किसी रिवॉर्ड को इसी पते द्वारा प्राप्त किया जाएगा. हालाँकि, किसी भी बॉन्ड को कॉल करने वाले से वापस ले लिया जाता है.

पैरामीटर्स:
- `disputer`: विवादकर्ता के रूप में पते को सेट करें.
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.

### proposePriceFor {#proposepricefor}

किसी दूसरे के पते के लिए एक प्राइस वैल्यू प्रस्तावित करता है. नोट करें: इस प्रस्ताव से मिलने वाले किसी भी रिवॉर्ड को इसी पते द्वारा प्राप्त किया जाएगा. हालाँकि, किसी भी बॉन्ड को कॉल करने वाले से वापस ले लिया जाता है.

पैरामीटर्स:
- `proposer`: प्रस्ताव भेजने वाले के रूप में पते को सेट करें.
- `requester`: क़ीमत का प्रारंभिक अनुरोध भेजने वाला.
- `identifier`: पहले से मौजूद अनुरोध को पहचानने के लिए क़ीमत की पहचान करने वाला.
- `timestamp`: पहले से मौजूद अनुरोध को पहचानने के लिए टाइमस्टैम्प.
- `ancillaryData`: अनुरोध की जा रही क़ीमत का सहायक डेटा.
- `proposedPrice`: प्रस्तावित की जा रही क़ीमत.

## ऑप्टिमिस्टिक ऑरेकल को इंटीग्रेट कर रहा है {#integrating-the-optimistic-oracle}

यह डेमो एक `OptimisticDepositBox` कॉन्ट्रैक्ट को सेट करता है जो यूज़र के ERC-20 टोकन के बैलेंस की कस्टडी लेता है.

एक स्थानीय टेस्टनेट ब्लॉक चेन पर, यूज़र wETH (रैप किए गए ईथर) को कॉन्ट्रैक्ट में डिपॉज़िट करेगा और USD में नामित wETH निकालेगा. उदाहरण के लिए, अगर यूज़र $10,000 USD of wETH, and the ETH/USD exchange rate is $2,000 निकालना चाहता है, वे 5 wETH निकाल लेंगे.

* यूज़र `OptimisticDepositBox` को DVM पर सक्षम किसी एक क़ीमत पहचानने वाले के साथ लिंक करता है.

* यूज़र wETH को `OptimisticDepositBox` में डिपॉज़िट करता है और इसे `ETH/USD` क़ीमत पहचानने वाले के साथ रजिस्टर करता है.

* अब यूज़र एक USD नामित रकम को अपने `DepositBox` को स्मार्ट कॉन्ट्रैक्ट कॉल के ज़रिये निकाल सकते हैं और ऑप्टिमिस्टिक ऑरेकल के साथ ऑनचेन ऑप्टिमिस्टिक क़ीमतें सक्षम करते हैं.

इस उदाहरण में, यूज़र एक ऑफ़-चेन `ETH/USD` प्राइस फ़ीड को संदर्भित किए बिना wETH की USD नामित रकम को ट्रांसफ़र कर पाने में सक्षम नहीं होगा. इस प्रकार, ऑप्टिमिस्टिक ऑरेकल यूज़र को एक संदर्भित क़ीमत को "पुल" करने में सक्षम बनाता है.

DVM के लिए भेजे गए क़ीमत के अनुरोधों के विपरीत, अगर कोई विवाद न हो तो ऑप्टिमिस्टिक ऑरेकल के लिए एक क़ीमत के अनुरोध का एक विशिष्ट लाइवनेस विंडो के भीतर ही हल किया जा सकता है, जोकि DVM वोटिंग अवधि से काफ़ी कम हो सकता है. लाइवनेस विंडो को कॉन्फ़िगर किया जा सकता है, लेकिन आमतौर इसमें, DVM के ज़रिए सेटलमेंट में लगने वाले 2-3 दिन के मुकाबले दो घंटे लगते हैं.

फ़िलहाल क़ीमत का अनुरोध करने वाले को DVM को फ़ीस का भुगतान करने की आवश्यकता नहीं है. अनुरोध करने वाला, प्रस्ताव भेजने वाले को एक रिवॉर्ड दे सकता है जिसने क़ीमत के अनुरोध का जवाब दिया है, लेकिन इस उदाहरण में रिवॉर्ड की वैल्यू `0`पर सेट है.

क़ीमत का प्रस्ताव भेजने वाला अपनी क़ीमत के साथ एक बॉन्ड पोस्ट करता है, जिसे क़ीमत के विवादित न होने पर, या अगर कोई विवाद, प्रस्ताव भेजने वाले के पक्ष में हल होता है तो रिफ़ंड कर दिया जाएगा. नहीं तो, इस बॉन्ड का इस्तेमाल DVM को अंतिम फ़ीस का भुगतान करने में इस्तेमाल किया जाता है और एक सफल विवादकर्ता को रिवॉर्ड का भुगतान करने के लिए इसे इस्तेमाल किया जाता है.

डेमो में, अनुरोध करने वाले को क़ीमत का प्रस्ताव भेजने वाले से एक अतिरिक्त बॉन्ड की आवश्यकता नहीं होती है, इसलिए पोस्ट किए गए कुल बांड wETH की फ़ाइनल फ़ीस के बराबर हैं जोकि फ़िलहाल 0.2 wETH है. लागू करने के विवरण के लिए, `proposePriceFor` फ़ंक्शन को `OptimisticOracle` [कॉन्ट्रैक्ट](https://docs-dot-uma-protocol.appspot.com/uma/contracts/OptimisticOracle.html) में देखें.

## डेमो को रन कर रहा है {#running-the-demo}

1. सुनिश्चित करें कि आपने [यहाँ](https://docs.umaproject.org/developers/setup) सेट अप के लिए सभी ज़रूरी स्टेप्स को फ़ॉलो किया है.
2. एक स्थानीय Ganache इंस्टैंस को (जैसे Kovan/Ropsten/Rinkeby/Mainnet नहीं) `yarn ganache-cli --port 9545` के साथ रन करें
3. एक दूसरी विंडो में, निम्नलिखित कमांड को चलाकर कॉन्ट्रैक्ट को माइग्रेट करें:

  ```bash
  yarn truffle migrate --reset --network test
  ```

1. `OptimisticDepositBox` [कॉन्ट्रैक्ट](https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/financial-templates/demo/OptimisticDepositBox.sol) को डिप्लॉय करने के लिए एक आसान यूज़र फ़्लो में जाएँ, और रेपो के रुट से निम्नलिखित डेमो स्क्रिप्ट को रन करें:

```bash
yarn truffle exec ./packages/core/scripts/demo/OptimisticDepositBox.js --network test
```

आपको निम्नलिखित आउटपुट को देखना चाहिए:

```
1. Deploying new OptimisticDepositBox
  - Using wETH as collateral token
  - Pricefeed identifier for ETH/USD is whitelisted
  - Collateral address for wETH is whitelisted
  - Deployed an OptimisticOracle
  - Deployed a new OptimisticDepositBox


2. Minting ERC20 to user and giving OptimisticDepositBox allowance to transfer collateral
  - Converted 10 ETH into wETH
  - User's wETH balance: 10
  - Increased OptimisticDepositBox allowance to spend wETH
  - Contract's wETH allowance: 10


3. Depositing ERC20 into the OptimisticDepositBox
  - Deposited 10 wETH into the OptimisticDepositBox
  - User's deposit balance: 10
  - Total deposit balance: 10
  - User's wETH balance: 0


4. Withdrawing ERC20 from OptimisticDepositBox
  - Submitted a withdrawal request for 10000 USD of wETH
  - Proposed a price of 2000000000000000000000 ETH/USD
  - Fast-forwarded the Optimistic Oracle and Optimistic Deposit Box to after the liveness window so we can settle.
  - New OO time is [fast-forwarded timestamp]
  - New ODB time is [fast-forwarded timestamp]
  - Executed withdrawal. This also settles and gets the resolved price within the withdrawal function.
  - User's deposit balance: 5
  - Total deposit balance: 5
  - User's wETH balance: 5
```

## कॉन्ट्रैक्ट फ़ंक्शन्स को समझाना {#explaining-the-contract-functions}

`OptimisticDepositBox`[कॉन्ट्रैक्ट कोड](https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/financial-templates/demo/OptimisticDepositBox.sol) बताता है कि Oracle के साथ कैसे बातचीत करें.

`constructor` फ़ंक्शन में UMA `_finderAddress` कॉन्ट्रैक्ट के लिए `Finder` आर्ग्युमेंट शामिल है, जो `OptimisticOracle` पते, स्वीकृत कोलेटरल और क़ीमत पहचानकर्ताओं की वाइटलिस्ट, और अन्य महत्वपूर्ण कॉन्ट्रैक्ट पतों की एक रजिस्ट्री रखता है.

यह `constructor` को कोलेटरल के प्रकार और क़ीमत पहचानकर्ताओं की वैधता जाँचने की अनुमति देता है और `OptimisticDepositBox` को `OptimisticOracle` ढूँढने और बाद में उससे इंटरैक्ट करने की अनुमति देता है.

`requestWithdrawal` फ़ंक्शन में `OptimisticOracle` को एक इंटरनल कॉल करना और `ETH/USD` की क़ीमत के लिए अनुरोध करना शामिल है. एक बार इसके वापस आने पर, यूज़र इसकी निकासी को पूरा करने के लिए `executeWithdrawal`को कॉल कर सकता है.

कोड की टिप्पणी में अधिक जानकारी और स्पष्टीकरण है, इसलिए कृपया एक नज़र निकालें कि अगर आप अधिक सीखने में रुचि रखते हैं.

## अतिरिक्त संसाधन {#additional-resources}

यहाँ UMA DVM से संबंधित कुछ अतिरिक्त संसाधन दिए गए हैं:

- [तकनीकी आर्किटेक्चर](https://docs.umaproject.org/oracle/tech-architecture)
- [इकोनॉमिक आर्किटेक्चर](https://docs.umaproject.org/oracle/econ-architecture)
- UMA के DVM डिज़ाइन पर [ब्लॉग पोस्ट](https://medium.com/uma-project/umas-data-verification-mechanism-3c5342759eb8)
- UMA के DVM डिज़ाइन पर [व्हाइटपेपर](https://github.com/UMAprotocol/whitepaper/blob/master/UMA-DVM-oracle-whitepaper.pdf)
- ऑप्टीमल फ़ीस की पॉलिसी के लिए [रिसर्च रेपो](https://github.com/UMAprotocol/research)
- गवर्नेंस के प्रस्तावों के लिए [UMIP रेपो](https://github.com/UMAprotocol/UMIPs)
