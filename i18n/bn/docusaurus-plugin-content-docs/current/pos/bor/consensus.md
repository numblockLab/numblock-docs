---
id: consensus
title: Bor Consensus
description: নতুন প্রযোজক আনতে বো মেকানিজম
keywords:
  - docs
  - matic
  - Bor Consensus
  - polygon
image: https://matic.network/banners/matic-network-16x9.png
---
import useBaseUrl from '@docusaurus/useBaseUrl';

# Bor Consensus {#bor-consensus}

বোর কনসেনসাস ক্লিক কনসেনসাস দ্বারা অনুপ্রাণিত হয়: [https://eips.ethereum.org/EIPS/eip-225](https://eips.ethereum.org/EIPS/eip-225)। ক্লিক একাধিক multiple  প্রযোজকের সাথে কাজ করে। সমস্ত প্রযোজক Clique API ব্যবহার করে নতুন প্রযোজকদের ভোট দেয়। তারা ব্লক তৈরি করে তা গ্রহণ করে।

Bor, স্প্যান এবং স্প্রিন্ট ম্যানেজমেন্ট পদ্ধতির মাধ্যমে নতুন প্রযোজক নিয়ে আসে।

## যাচাইকারী {#validators}

Polygon একটি প্রুফ-অফ-স্টেক সিস্টেম। যে কেউ Ethereum স্মার্ট-কন্ট্র্যাক্টে তাদের ম্যাটিক টোকেন স্টেক করতে পারেন, "স্টেকিং কন্ট্র্যাক্ট" এবং সিস্টেমের জন্য একজন যাচাইকারী হয়ে উঠতে পারেন।

```jsx
function stake(
	uint256 amount,
	uint256 heimdallFee,
	address signer,
	bool acceptDelegation
) external;
```

যাচাইকারীরা একবার Heimdall-এ সক্রিয় হলেই তারা `bor`মডিউলের মাধ্যমে প্রযোজক হিসাবে নির্বাচিত হবেন।

বিশৃঙ্খলার মধ্যে স্প্যান ম্যানেজমেন্ট বুঝতে Bor ওভারভিউ দেখুন: [Bor ওভারভিউ](https://www.notion.so/Bor-Overview-c8bdb110cd4d4090a7e1589ac1006bab)

## স্প্যান {#span}

ব্লকের একটি লজিক্যাল সংজ্ঞায়িত সেট যার জন্য সমস্ত উপলব্ধ যাচাইকারী থেকে যাচাইকারী একটি সেট বেছে নেওয়া হয়। স্প্যান-বিশদ API-গুলির মাধ্যমে Heimdall স্প্যানের বিস্তারিত তথ্য সরবরাহ করে।

```go
// HeimdallSpan represents span from heimdall APIs
type HeimdallSpan struct {
	Span
	ValidatorSet      ValidatorSet `json:"validator_set" yaml:"validator_set"`
	SelectedProducers []Validator  `json:"selected_producers" yaml:"selected_producers"`
	ChainID           string       `json:"bor_chain_id" yaml:"bor_chain_id"`
}

// Span represents a current bor span
type Span struct {
	ID         uint64 `json:"span_id" yaml:"span_id"`
	StartBlock uint64 `json:"start_block" yaml:"start_block"`
	EndBlock   uint64 `json:"end_block" yaml:"end_block"`
}

// Validator represents a volatile state for each Validator
type Validator struct {
	ID               uint64         `json:"ID"`
	Address          common.Address `json:"signer"`
	VotingPower      int64          `json:"power"`
	ProposerPriority int64          `json:"accum"`
}
```

প্রতিটি ব্লকের জন্য কনসেনসাস ডেটা সহ অবস্থার ডেটা স্টোর করতে Geth (এই ক্ষেত্রে, Bor)`snapshot` ব্লক ব্যবহার করে।

স্প্যানের প্রত্যেক যাচাইকারীর ভোট দেওয়ার ক্ষমতা থাকে। তাদের ক্ষমতার উপর ভিত্তি করে, তারা ব্লক প্রযোজক হিসাবে নির্বাচিত হন। ক্ষমতা যত বেশি হবে, ব্লক প্রযোজক হয়ে উঠার সম্ভাবনা তত বেশি থাকবে। একই কাজের জন্য Bor, Tendermint এর অ্যালগরিদম ব্যবহার করে। সোর্স: [https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go](https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go)

## স্প্রিন্ট {#sprint}

একটি স্প্যানের মধ্যে ব্লকগুলির একটি সেট, যার জন্য ব্লকগুলি তৈরি করতে শুধুমাত্র একজন ব্লক প্রযোজককে নির্বাচন করা হয়। স্প্রিন্ট সাইজ হচ্ছে স্প্যান আকারের একটি ফ্যাক্টর। বর্তমান স্প্রিন্টের জন্য বর্তমান প্রস্তাবক/প্রযোজক পেতে Bor `validatorSet`ব্যবহার করে।

```go
currentProposerForSprint := snap.ValidatorSet().Proposer
```

বর্তমান প্রস্তাবকারী ছাড়াও, Bor ব্যাক-আপ প্রযোজক নির্বাচন করে।

## একটি ব্লক অনুমোদন করা {#authorizing-a-block}

Bor-এ থাকা প্রযোজকদের স্বাক্ষরকারীও বলা হয়ে থাকে, যেহেতু নেটওয়ার্কের জন্য একটি ব্লক অনুমোদন করতে হয়, তাই প্রযোজকদে**র শুধু স্বাক্ষরটি ছাড়া সবকিছ**ু  থাকা ব্লকের হ্যাশ স্বাক্ষর করতে হয়। অর্থাৎ হ্যাশে হেডারের প্রতিটি ক্ষেত্র এবং সেইসাথে 65-বাইট স্বাক্ষরের সাফিক্সের ব্যতিক্রম `extraData` থাকে।

এই হ্যাশটি স্ট্যান্ডার্ড `secp256k1`বক্ররেখা ব্যবহার করে স্বাক্ষর করা হয় এবং ফলস্বরূপ 65-বাইট স্বাক্ষরটি পরবর্তী 65-বাইট সাফিক্স হিসাবে `extraData`-এ এম্বেড করা হয়।

প্রতিটি স্বাক্ষরিত ব্লক একটি অসুবিধায় অর্পণ করা হয় যা ব্লককে ভারি করে তোলে। ইন-টার্ন স্বাক্ষর, আউট অফ টার্নের একটি `DIFF_NOTURN`-এর চেয়ে (`DIFF_INTURN`) বেশি ভারি হয়।

### অনুমোদন কৌশল {#authorization-strategies}

যতক্ষণ প্রযোজক উপরের বৈশিষ্ট্যগুলির সাথে একমত হন, ততক্ষণ তারা ব্লকগুলিকে উপযুক্ত মনে করলে সেগুলিকে অনুমোদন এবং বিতরণ করতে পারেন। তবে, নিম্নলিখিত প্রস্তাবিত কৌশলটি নেটওয়ার্ক ট্রাফিক এবং ছোটোখাটো দ্বিধাবিভাজন কমাবে, তাই এটি একটি প্রস্তাবিত বৈশিষ্ট্য:

- একজন প্রযোজককে একটি ব্লক (অনুমোদিত তালিকায় রয়েছে) স্বাক্ষর করার অনুমতি দিলে
    - পরবর্তী ব্লকের (মূল + `Period`) এর কাম্য স্বাক্ষরের সময় গণনা করুন
    - প্রযোজক ইন-টার্ন এ থাকলে, আগমনের সঠিক সময়ের জন্য অপেক্ষা করুন, স্বাক্ষর করুন এবং অবিলম্বে সম্প্রচার করুন
    - প্রযোজক আউট-অফ-টার্ন এ থাকলে, স্বাক্ষর করতে `wiggle` দেরি করুন

এই ছোটো কৌশলটি নিশ্চিত করবে যে ইন-টার্ন প্রযোজক (যার ব্লক বেশি ভারি) এর আউট-অফ-টার্ন এর স্বাক্ষরকারীদের তুলনায় স্বাক্ষর এবং প্রচার করার ক্ষেত্রে সামান্য সুবিধা রয়েছে। উপরন্তু, এই কৌশলটি প্রযোজকদের সংখ্যার একটি বৃদ্ধি সহ পরিমাপের থেকে কিছুটা বাড়তির অনুমতি দেয়।

### আউট-অফ-টার্ন স্বাক্ষর করা {#out-of-turn-signing}

ইন-টার্ন প্রযোজক একটি ব্লক তৈরি না করলে, Bor একটি ব্যাকআপ হিসাবে একাধিক ব্লক প্রযোজক বেছে নেয়। এটি বিভিন্ন কারণে ঘটতে পারে, যেমন:

- ব্লক প্রযোজকের নোড কাজ করছে না
- ব্লক প্রযোজক ব্লকটি আটকাবার চেষ্টা করছে
- ব্লক প্রযোজক স্বেচ্ছায় একটি ব্লক তৈরি করছেন না।

উপরোক্ত ঘটনাগুলি ঘটলে, Bor এর ব্যাকআপ প্রক্রিয়া কাজ শুরু করে।

যে কোনও সময়ে, যাচাইকারীদের সেট তাদের স্বাক্ষরকারীর ঠিকানার ভিত্তিতে সজ্জিত একটি অ্যারে হিসাবে সংরক্ষণ করা হয়। ধরা যাক যে যাচাইকারী সেটটি A, B, C, D হিসাবে ক্রমাঙ্কিত করা হয় এবং এটি একটি ব্লক তৈরি করার জন্য C-এর পালা। পর্যাপ্ত সময়ের মধ্যে C একটি ব্লক তৈরি না করলে, সেটি তৈরি করার জন্য D-এর পালা হয়ে যায়। D না করলে পরে A এবং তারপর B।

যাইহোক, C একটি ব্লক তৈরি করে এবং প্রচার করার আগে কিছু সময় থাকবে, তাই একটি ব্লক তৈরি শুরু করার আগে ব্যাকআপ যাচাইকারীরা একটি নির্দিষ্ট পরিমাণ সময় অপেক্ষা করবেন। এই বিলম্বকে উইগেল বলা হয়।

### উইগেল {#wiggle}

উইগেল হল একজন প্রযোজককের একটি ব্লক তৈরি শুরু করার আগের অপেক্ষার সময়।

- ধরা যাক, শেষ ব্লক (n-1), `t`সময়ে তৈরি করা হয়েছিল।
- বর্তমান এবং পরবর্তী ব্লকের মধ্যে একটি ন্যূনতম সময়ের বিলম্ব আমরা একটি পরিবর্তনশীল প্যারামিটারের দ্বারা কার্যকর করি`Period`।
- আদর্শ ক্ষেত্রে, C `Period`এর জন্য অপেক্ষা করবে এবং তারপর ব্লকটি তৈরি এবং প্রচার করবে। যেহেতু Polygon-এ ব্লক সময়গুলি বেশ কম (2-4s) হিসেবে ডিজাইন করা হচ্ছে, তাই প্রচারের বিলম্বে`Period`র মতো একই মান হবে বলে মনে করা হচ্ছে।
- তাই যদি D `2 * Period`সময়ের মধ্যে একটি নতুন ব্লক দেখতে না পায়, তাহলে D অবিলম্বে একটি ব্লক তৈরি করা শুরু করে। বিশেষত, D এর উইগেল সময়`2 * Period * (pos(d) - pos(c))` হিসাবে সংজ্ঞায়িত করা হয় যেখানে`pos(d) = 3` এবং`pos(c) = 2` মূল্যায়নকারীর সেট-এ। ধরে নেওয়া হ`Period = 1`য়, , D এর জন্য উইগেল হল 2s।
- এখন Dও একটি ব্লক তৈরি না করলে, `2 * Period * (pos(a) + len(validatorSet) - pos(c)) = 4s`-এর উইগেল সময় পেরিয়ে গেলে A একটি উৎপাদন করা শুরু করবে।
- অনুরূপভাবে, C-এর জন্য উইগেল হল `6s`

### দ্বিধাবিভাজনগুলির সমাধান করা {#resolving-forks}

উপরের পদ্ধতিটি একটি নির্দিষ্ট পরিসরে চেইনকে আরও শক্তিশালী করে, তবে এটিতে দ্বিধাবিভাজনগুলি আসার সম্ভাবনা তৈরি হয়। এটি প্রকৃতপক্ষে সম্ভব হতে পারে যে C একটি ব্লক তৈরি করেছে, কিন্তু প্রচারের ক্ষেত্রে প্রত্যাশিতর থেকে বেশি বিলম্ব ছিল এবং তাই Dও একটি ব্লক তৈরি করেছে, তাই তার ফলে অন্তত 2টি দ্বিধাবিভাজন হয়।

সমাধানটি সহজ - বেশি অসুবিধা থাকা চেইন বেছে নিন। তাহলে প্রশ্নটি হল আমরা আমাদের সেটআপে একটি ব্লকের অসুবিধা কীভাবে সংজ্ঞায়িত করব?

### অসুবিধা {#difficulty}

- একটি ইন-টার্ন স্বাক্ষরকারীর (ধরে নেওয়া যাক c) দ্বারা সৃষ্ট একটি ব্লকের জন্য অসুবিধাটি সর্বোচ্চ =`len(validatorSet)` বলে সংজ্ঞায়িত করা হয়।
- যেহেতু D হচ্ছে এর পরে লাইনে থাকা প্রযোজক; তাই যদি এবং যখন এমন পরিস্থিতি উদ্ভূত হয় যে D ব্লকটি তৈরি করছে; ব্লকের জন্য অসুবিধা`len(validatorSet) - (pos(d) - pos(c))` হিসেবে উইগেলে যেভাবে সংজ্ঞায়িত করা আছে ঠিক সেভাবেই সংজ্ঞায়িত করা হবে, যা হ`len(validatorSet) - 1`ল
- একটি ব্যাকআপ হিসাবে কাজ করার সময় A-র তৈরি করা ব্লকের জন্য অসুবিধা `len(validatorSet) - (pos(a) + len(validatorSet) - pos(c))`হয়ে যায় `2`যা

এখন প্রতিটি ব্লকের অসুবিধা সংজ্ঞায়িত করা হলে, একটি দ্বিধাবিভাজনের অসুবিধা সেই দ্বিধাবিভাজনের ব্লকের অসুবিধার সমষ্টি মাত্র। যদি একটি দ্বিধাবিভাজন নির্বাচন করতেই হয়, তাহলে বেশি অসুবিধা থাকা একটিকে বেছে নেওয়া হয়, কারণ এটি হ'ল ইন-টার্ন ব্লক প্রযোজকদের দ্বারা ব্লক তৈরি করা ঘটনাটির একটি প্রতিফলন। এটি শুধুমাত্র Bor-এ ব্যবহারকারীর কাছে কিছু চূড়ান্ত অনুভূতি প্রদান করতে করা হয়।

## পরিবর্তন দেখুন {#view-change}

প্রতিটি স্প্যানের পরে, Bor ভিউটি পরিবর্তন করে। অর্থাৎ এটি পরবর্তী স্প্যানের জন্য এটি নতুন প্রযোজক নিয়ে আসে।

### স্প্যান সমর্পণ করুন {#commit-span}

বর্তমান স্প্যান প্রায় শেষ হয়ে যায় (বিশেষত স্প্যানে শেষের আগের স্প্রিন্টের শেষে), Bor, Heimdall থেকে একটি নতুন স্প্যান টানে। এটি Heimdall নোডে একটি সাধারণ HTTP কল। একবার এই ডেটা সংগ্রহ হলে, সিস্টেম কলের মাধ্যমে BorValidatorSet জেনেসিস চুক্তিতে একটি `commitSpan`কল করা হয়।

Bor ব্লকের হেডারের মধ্যে প্রযোজকদের বাইটও সেট করে। Bor-এর দ্রুত সিঙ্ক করার সময় এটি প্রয়োজনীয়। দ্রুত সিঙ্ক করার সময়, Bor একসাথে অনেক হেডারকে সিঙ্ক এবং বহাল করে যদি ব্লকগুলি অনুমোদিত প্রযোজকদের দ্বারা তৈরি হয়।

প্রতিটি স্প্রিন্টের শুরুতে, Bor পরবর্তী প্রযোজকদের জন্য পূর্ববর্তী হেডারের থেকে হেডারের বাইটগুলি নিয়ে আসে এবং `ValidatorSet`অ্যালগরিদমের উপর ভিত্তি করে ব্লকগুলি তৈরি করা শুরু করে।

একটি ব্লকের জন্য হেডার কেমন দেখতে হয় তা এখানে দেখানো হল:

```js
header.Extra = header.Vanity + header.ProducerBytes /* optional */ + header.Seal
```

<img src={useBaseUrl("img/Bor/header-bytes.svg")} />

## Ethereum চেইন থেকে স্টেট সিঙ্ক {#state-sync-from-ethereum-chain}

Bor একটি পদ্ধতি প্রদান করে, যেখানে মূল ethereum চেইনে নির্দিষ্ট কিছু ইভেন্ট Bor-এ রিলে করা হয়। প্লাজমা চুক্তিগুলিতে জমাগুলো যেভাবে প্রক্রিয়া করা হয়।

1. Ethereum-এ যে কোনও চুক্তিকে `StateSender.sol`-এ [syncState](https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L33) বলা যেতে পারেl এই কলটি `StateSynced`থেকে যে ইভেন্ট পাওয়া যায়: https://github.com/maticnetwork/contracts/blob/develop/contracts/root/statySyncer/StateSender.sol#L38

  ```js
  event StateSynced(uint256 indexed id, address indexed contractAddress, bytes data)
  ```

2. Heimdall এই ইভেন্টে listens ে এবং `function proposeState(uint256 stateId)`কল। এই `StateReceiver.sol`কারণে পেন্ডিং স্টেট পরিবর্তন আইডি'র জন্য একটি স্টোর হিসাবে কাজ করে। মনে রাখবে যে যতক্ষণ পর্যন্ত বর্তমান যাচাইকারীর সেটে একজন যাচাইকারী দ্বারা এমনকি একটি 0 গ্যাস ফি দিয়ে`proposeState` লেনদেনটি তৈরি করা হবে ততক্ষণ সেটি প্রক্রিয়া করা হবে: https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/StateReociver.sol#L24

3. প্রতিটি স্প্রিন্টের শুরুতে, Bor, Heimdall থেকে স্টেটগুলি ব্যবহার করে বাকি থাকা স্টেটের পরিবর্তনগুলি সম্পর্কে বিস্তারিত তথ্য পেশ করে এবং একটি সিস্টেম কল ব্যবহার করে Bor স্টেটে সেগুলি বহাল করে। `commitState` এখানে দেখুন: https://github.com/maticnetwork/genesis-contracts/blob/f85d0409d2a99dff53617ad5429101d9937e3fc3/contracts/StateReceiver.sol#L41
