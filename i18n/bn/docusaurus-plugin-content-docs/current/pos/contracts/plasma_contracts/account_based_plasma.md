---
id: account_based_plasma
title: অ্যাকাউন্ট ভিত্তিক প্লাজমা
description: রক্তরসের একটি অ্যাকাউন্ট-ভিত্তিক বাস্তবায়ন
keywords:
  - docs
  - matic
  - Account Based Plasma
  - polygon
  - implementation
image: https://matic.network/banners/matic-network-16x9.png
---

# অ্যাকাউন্ট ভিত্তিক প্লাজমা {#account-based-plasma}

Polygon প্লাজমা [প্লাজমা MoreVP ](https://ethresear.ch/t/more-viable-plasma/2160) অনুরূপ একটি মডেল অনুসরণ করে, কিন্তু অন্যান্য UTXO-ভিত্তিক বাস্তবায়নের তুলনায় এটি একটি **অ্যাকাউন্ট-ভিত্তিক বাস্তবায়ন**। সাইডচেইন EVM-সামঞ্জস্যপূর্ণ। MoreVP নির্মাণ ব্যবহার করে, আমরা নিশ্চিতকরণ স্বাক্ষরের প্রয়োজনীয়তাও দূর করি।

## PoS স্তর এবং চেকপয়েন্ট {#pos-layer-and-checkpoints}

Polygon নেটওয়ার্ক দ্রুত ব্লকটাইম অর্জনের জন্য চেকপয়েন্টিং স্তরে প্রুফ অফ স্টেক এবং ব্লক প্রযোজকদের ব্লক প্রযোজকের দ্বৈত কৌশল ব্যবহার করে এবং চেকপয়েন্ট এবং জালিয়াতির প্রমাণ ব্যবহার করে মূল চেইনে সম্পূর্ণতা অর্জন করে।

Polygon নেটওয়ার্কের চেকপয়েন্টিং লেয়ারে, Polygon নেটওয়ার্কের ব্লক স্তরের প্রতি কয়েকটি ব্লকের জন্য,
 একটি (পর্যাপ্ত বন্ডেড) যাচাইকারী ব্লক লেয়ারের সমস্ত ব্লক যাচাই করার পরে এবং শেষ চেকপয়েন্ট থেকে ব্লক হ্যাশের মার্কেল ট্রি তৈরি করার পরে মূল চেইনে একটি চেকপয়েন্ট তৈরি করবে।

মূল চেইনে চূড়ান্ততা প্রদানের পাশাপাশি, চেকপয়েন্টগুলি প্রত্যাহারে ভূমিকা পালন করে যেহেতু তাদের কাছে ব্যবহারকারীর প্রত্যাহারের ক্ষেত্রে টোকেনগুলির প্রুফ-অফ-বার্ন (প্রত্যাহার) আছে। এটি ব্যবহারকারীদের Patricia Merkle প্রুফ এবং শিরোনাম ব্লক প্রুফ ব্যবহার করে রুট চুক্তিতে তাদের অবশিষ্ট টোকেনগুলি প্রমাণ করতে সক্ষম করে। মনে রাখবেন যে অবশিষ্ট টোকেনগুলি প্রমাণ করার জন্য, হেডার ব্লকটি অবশ্যই PoS (স্টেকহোল্ডার) এর মাধ্যমে রুট চেইনের প্রতি প্রতিশ্রুতিবদ্ধ হতে হবে। প্রত্যাহারের প্রক্রিয়াটি যথারীতি Ethereum গ্যাস ফি বহন করবে।  আমরা নিগমন গেমগুলির জন্য চেকপয়েন্টগুলি প্রচুর পরিমাণে ব্যবহার করি।

## UTXO-like ইভেন্ট লগ {#utxo-like-event-logs}

ERC20/ERC721 স্থানান্তরের জন্য, এটি একটি UTXO-like ইভেন্ট লগ ডেটা কাঠামো ব্যবহার করে অর্জন করা হয়। নিচে রেফারেন্সের জন্য একটি  `LogTransfer`ইভেন্ট রয়েছে।

```jsx
event LogTransfer(
    address indexed token,
    address indexed from,
    address indexed to,
    uint256 amountOrTokenId,
    uint256 input1, // previous account balance of the sender
    uint256 input2, // previous account balance of the receiver
    uint256 output1, // new account balance of the sender
    uint256 output2 // new account balance of the receiver
);
```

তাই, মূলত প্রতিটি ERC20 / ERC721 স্থানান্তর এই ইভেন্টটি নির্গত করে এবং প্রেরক এবং গ্রাহকের পূর্ববর্তী হিসাব-নিকাশ (`input1` এবং  `input2`) টিএক্সের ইনপুট (UTXO-এর মতো) হয়ে যায় এবং নতুন ব্যালেন্স আউটপুট (`output1` এবং `output2`) হয়ে যায়। সমস্ত সম্পর্কিত `LogTransfer` ইভেন্টগুলি একত্রিত করার মাধ্যমে স্থানান্তরগুলি ট্র্যাক করা হয়।

##  নিগমন গেম {#exit-games}

যেহেতু ব্লকগুলি একক ব্লক প্রযোজক (বা খুব কম) দ্বারা উত্পাদিত হয়, তাই এটি জালিয়াতির জন্য একটি পৃষ্ঠপ্রকাশ করে। আমরা সংক্ষেপে আক্রমণের পরিস্থিতিগুলি নিয়ে আলোচনা করব এবং তারপরে প্লাজমা কীভাবে কোনও ব্যবহারকারীকে সুরক্ষা দেয় সে সম্পর্কে কথা বলব।

## আক্রমণকারী ভেক্টর {#attack-vectors}

### Malicious  অপারেটর {#malicious-operator}
নিম্নলিখিত পরিস্থিতিতে আলোচনা করা হয়েছে যেখানে অপারেটর দূষিত হতে পারে এবং প্রতারণা করার চেষ্টা করতে পারে।

1. অপ্রত্যাশিত টোকেন / ডাবল ব্যয় / খারাপ রসিদ যা প্রতারণামূলকভাবে বৃদ্ধি পায় (একটি কার্যকারক নিয়ন্ত্রিত অ্যাকাউন্টের জন্য) / টোকেন ব্যালেন্স হ্রাস করে (ব্যবহারকারীর জন্য) ।
2. ডেটা অপ্রাপ্যতা একজন ব্যবহারকারী একটি tx পাঠানোর পরে, ধরা যাক কার্যকারক প্লাজমা ব্লকে টিএক্স অন্তর্ভুক্ত করেছিল তবে ব্যবহারকারীর কাছে চেইন ডেটা অনুপলব্ধ করে রেখেছিল। সেক্ষেত্রে, যদি একজন ব্যবহারকারী একটি পুরানো tx থেকে প্রস্থান শুরু করেন, তাহলে তাদের সাম্প্রতিকতম tx প্রদর্শন করে অন-চেইন চ্যালেঞ্জ করা যেতে পারে। ব্যবহারকারীকে দুঃখ দেওয়া সহজ হয়ে যায়।
3.  
সবচেয়ে খারাপ ক্ষেত্রে খারাপ চেকপয়ন্ট, একজন অপারেটর A.1 এবং (অথবা) A.2 কার্যকর করতে পারে এবং মূল চেইনে সেই অবৈধ স্টেটের লেনদেনগুলো প্রতিজ্ঞাবদ্ধ করার জন্য বৈধকারীদের সাথে মিলিত হতে পারে।
4. সাইড চেইন থামানো কার্যকারক ব্লক উৎপাদন বন্ধ করে দেয় এবং চেইনটি বন্ধ হয়ে যায়। যদি একটি নির্দিষ্ট সময়ের জন্য একটি চেকপয়েন্ট জমা দেওয়া না হয়, তবে পাশের চেইনটি রুট চেইনে নিরূদ্ধ হিসাবে চিহ্নিত করা সম্ভব হবে। এর পরে আর কোনও চেকপয়েন্ট জমা দেওয়া যাবে না।

উপরে বা অন্যথায় তালিকাভুক্ত কারণগুলির জন্য, যদি প্লাজমা চেইনটি দুর্বৃত্ত হয়ে যায় তবে ব্যবহারকারীর ব্যাপকভাবে প্রস্থান করা শুরু করতে হবে এবং আমরা মূল চেইনে প্রস্থান নির্মাণ প্রদানের আকাঙ্খা দেই যাতে ব্যবহারকারীরা সুবিধা নিতে পারে, যদি এবং যখন সময় আসে।

### দূষিত ব্যবহারকারী {#malicious-user}

1. ব্যবহারকারী একটি প্রতিশ্রুতিবদ্ধ tx থেকে প্রস্থান শুরু করে কিন্তু সাইড চেইনে টোকেনগুলি খরচ করতে থাকে। দ্বিগুণ ব্যয়ের অনুরূপ তবে 2টি চেইন জুড়ে।

আমরা  [MoreVp 7](https://ethresear.ch/t/more-viable-plasma/2160) এর ধারণার উপর ভিত্তি করে তৈরি করছি। সংক্ষেপে, MoreVP প্রস্থান অগ্রাধিকার গণনা করার জন্য একটি নতুন উপায় প্রবর্তন করে, যাকে "কনিষ্ঠতম-ইনপুট" অগ্রাধিকার বলা হয়। আউটপুট বয়স দ্বারা প্রস্থান আদেশ করার পরিবর্তে, moreVP সর্বকনিষ্ঠ ইনপুট বয়স দ্বারা প্রস্থান আদেশ করে। এটির প্রভাব রয়েছে যা আউটপুট থেকে প্রস্থান করে, এমনকি যদি তাদের "অপ্রত্যাশিত" লেনদেনের পরেও আটকে থাকা ব্লকগুলিতে অন্তর্ভুক্ত করা হয়, তবুও সঠিকভাবে প্রক্রিয়া করা হবে যতক্ষণ তারা কেবল বৈধ ইনপুটগুলি থেকে স্টেম করবে। আমরা `getAge` সংজ্ঞায়িত করি যা অন্তর্ভুক্ত tx-এর জন্য বয়স নির্ধারণ করে। এটি [সর্বনিম্ন কার্যকর প্লাজমা 1](https://ethresear.ch/t/minimal-viable-plasma/426) এ সংজ্ঞায়িত করা হয়েছে।

```jsx
function getAge(receipt) {
  const { headerNumber, plasmaBlockNum, txindex, oindex } = receipt
  return f(headerNumber, plasmaBlockNum, txindex, oindex) // multiplied with their respective weights
}
```

## প্রস্থান দৃশ্যকল্প {#exit-scenarios}

আমরা প্রস্থান পরিস্থিতিতে আলোচনা চালিয়ে যাওয়ার আগে কিছু terminology চালু করব:

- **প্রত্যাহার**: একজন ব্যবহারকারী যিনি প্লাজমা চেইন প্রস্থান করতে চায়।
- **প্রতিশ্রুতিবদ্ধ tx**: একটি tx যা একটি Polygon চেইন ব্লকে অন্তর্ভুক্ত করা হয়েছে এবং রুট চেইনে চেকপয়েন্ট করা হয়েছে।
- **tx ব্যয়** করুন:  
একটি tx যা ব্যবহারকারীর দ্বারা স্বাক্ষরিত একটি কর্মের প্রতিক্রিয়া হিসাবে ব্যবহারকারীর টোকেনের হিসাব-নিকাশ পরিবর্তন করে (আগত টোকেন স্থানান্তর অন্তর্ভুক্ত নয়)। এটি সম্ভবত একজন ব্যবহারকারী স্থানান্তর, বার্ন টিএক্স ইত্যাদি শুরু করেছে।
- **রেফারেন্স tx**:
Txt নির্দিষ্ট ব্যবহারকারী এবং টোকেনের জন্য প্রস্থান tx এর আগে আছে। আমাদের অ্যাকাউন্ট হিসাব-নিকাশ ভিত্তিক UTXO স্কিমে সংজ্ঞায়িত হিসাবে,রেফারেন্স tx-এর আউটপুট tx থেকে প্রস্থান করা ইনপুট হয়ে যায়।
- **MoreVP প্রস্থান অগ্রাধিকার**:
একটি নির্দিষ্ট tx-এর সর্বকনিষ্ঠ ইনপুট (রেফারেন্স txs মধ্যে) এর বয়স। এটি প্রায়শই প্রস্থান অগ্রাধিকার গণনা করার জন্য ব্যবহার করা হবে।

### টোকেন বার্ন {#burn-tokens}

সাইডচেইন থেকে প্রস্থান করতে, একজন ব্যবহারকারী প্লাজমা চেইনে একটি  *প্রত্যাহার ওরফে বার্ন টোকেন*  tx চালু করবেন
। এই tx একটি ইভেন্ট `Withdraw`প্রকাশ করবে।

```jsx
event Withdraw(
    address indexed token,
    address indexed from,
    uint256 amountOrTokenId,
    uint256 input1,
    uint256 output1
);
```

এখানে `input1` প্রশ্নে থাকা টোকেনের জন্য ব্যবহারকারীর পূর্ববর্তী ব্যালেন্স নির্দেশ করে এবং `output1`সাইড চেইনে অবশিষ্ট টোকেনের সংখ্যা নির্দেশ করে।
এই নির্মাণ আমাদের অ্যাকাউন্ট ভিত্তিক *UTXO* স্কিমের সাথে সামঞ্জস্যপূর্ণ। একজন ব্যবহারকারী মূল চেইনে টোকেনগুলি প্রত্যাহার করার জন্য এই প্রত্যাহার টিএক্সের রসিদটি উপস্থাপন করবেন। এই রসিদ উল্লেখ করার সময়, ব্যবহারকারীকে নিম্নলিখিতগুলিও প্রদান করতে হবে:

1. একটি সাইড চেইন ব্লকের মধ্যে একটি রসিদ অন্তর্ভুক্তির মার্কেল প্রুফ (`receiptsRoot`)
2. একটি সাইড চেইন ব্লকে একটি ট্রানজেকশনের অন্তর্ভুক্তির বিষয়ে মার্কেল প্রুফ ( `transactionsRoot`)
3. রুট চেইনের চেকপয়েন্টে সাইড চেইন ব্লক হেডারের অন্তর্ভুক্তির প্রুফ

```jsx
startExit(withdrawTx, proofOfInclusion /* of the withdrawTx in the checkpoint */) {
  Verify inclusion of withdrawTx in checkpoint using proofOfInclusion
  Verify msg.sender == ecrecover(withdrawTx)

  uint age = getAge(withdrawTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}
```

যখনই একজন ব্যবহারকারী প্লাজমা চেইন থেকে প্রস্থান করতে চান, তখনই তাদের (অথবা তাদের ক্লায়েন্ট অ্যাপের দ্বারা বিমূর্ত করা হয়েছে যেমন wallet) পাশের চেইনের টোকেনগুলিকে বার্ন করা, এটি চেকপয়েন্টেড করার জন্য অপেক্ষা করা এবং তারপরে চেকপয়েন্ট থেকে প্রস্থান শুরু করা উচিত।

### গত ERC20/721 ট্রান্সফার থেকে Exit (MoreVP) {#exit-from-the-last-erc20-721-transfers-morevp}

দৃশ্যটি বিবেচনা করুন, ব্যবহারকারী সাইড চেইনে একটি ERC20 ট্রান্সফার করেছে। অপারেটর ব্যবহারকারীর স্থানান্তরের ঠিক আগে একটি আকস্মিক টিএক্স যোগ করেছে এবং এই ব্লকটি চেকপয়েন্ট করার জন্য যাচাইকারীদের সাথে মিলিত হয়েছে। এই পরিস্থিতিতে এবং আরও সাধারণভাবে, উপরে আলোচনা করা অ্যাটাক ভেক্টর A1 থেকে A3-এ, কোনও ক্ষতিকারক tx অন্তর্ভুক্ত হওয়ার আগে ব্যবহারকারীর তাদের টোকেনগুলি বার্ন করার সুযোগ নাও থাকতে পারে এবং তাই রুট চেইনের শেষ চেকপয়েন্টযুক্ত tx থেকে প্রস্থান শুরু করতে হবে। - এই কারণে, বার্ন প্রস্থান ছাড়াও, আমাদের অন্যদের মধ্যে ERC20 / 721 স্থানান্তরের মতো বিভিন্ন টিএক্স থেকে প্রস্থানকে সমর্থন করতে হবে। এটি আক্রমণ ভেক্টরের উপর ভিত্তি করে এবং ২ টি পরিস্থিতি ভেঙে তৈরি করা:

**বহির্মুখী স্থানান্তর: ** আমি একজন ব্যবহারকারীর কাছে কিছু টোকেন স্থানান্তর করেছি, তবে আমি লক্ষ্য করেছি যে অপারেটরটি আমার স্থানান্তর tx অন্তর্ভুক্ত করার আগে ব্লক / চেকপয়েন্টে একটি দূষিত টিএক্স অন্তর্ভুক্ত করেছে।
আমাকে চেইন থেকে বের হওয়া শুরু করতে হবে। আমি ট্রান্সফার tx থেকে প্রস্থান শুরু করব। MoreVP-তে সংজ্ঞায়িত হিসাবে, আমাকে একটি রেফারেন্স tx (*ইনপুট UTXO*) প্রদান করতে হবে যা প্রস্থানের প্রস্থান অগ্রাধিকারকে সংজ্ঞায়িত করবে। সুতরাং, আমি একটি tx উল্লেখ করব যা আমার টোকেনের হিসাব-নিকাশ আপডেট করেছে এবং কেবল বহির্গামী স্থানান্তর tx চালিয়ে গেছে

```jsx
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the user after the input tx was executed >= tokens being transferred in the exitTx
  Verify msg.sender == ecrecover(exitTx)

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

**ইনকামিং ট্রান্সফার:** আমি লক্ষ্য করেছি যে আমার ইনকামিং ট্রান্সফার tx অন্তর্ভুক্ত করার আগে, অপারেটর ব্লক/চেকপয়েন্ট একটি দূষিত tx অন্তর্ভুক্ত করেছে। প্রতিপক্ষের হিসাব-নিকাশ উল্লেখ করার সময় আমি ইনকামিং ট্রান্সফার টিএক্স থেকে প্রস্থান শুরু করব -  
কারণ এখানে *ইনপুট UTXO* হল প্রতিপক্ষের টোকেন ব্যালেন্স।

```
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the counterparty after the input tx was executed >= tokens being transferred in the exitTx
  Verify input.sender == ecrecover(exitTx) && input.receiver == msg.sender

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

### একটি ইন-ফ্লাইট লেনদেনের থেকে প্রস্থান করুন (MoreVP) {#exit-from-an-in-flight-transaction-morevp}

এই দৃশ্যটি ডেটা অনুপলব্ধতার পরিস্থিতি মোকাবেলা করার জন্য।
ধরা যাক আমি একটি tx তৈরি করেছি কিন্তু আমি জানি না যে ডেটা অনুপলব্ধতার কারণে সেই tx অন্তর্ভুক্ত করা হয়েছে কিনা। আমি শেষ চেকপয়েন্টেড tx উল্লেখ করে এই ইন-ফ্লাইট tx থেকে প্রস্থান শুরু করতে পারি।
ব্যবহারকারীকে সতর্ক থাকতে হবে যে যখনই তারা একটি MoreVP ধরনের প্রস্থান শুরু করে তখন কোনও tx সমূহ তৈরি না করা, অন্যথায় তাদের চ্যালেঞ্জ করা হবে।

**নোট:** একটি MoreVP ধরনের নির্মাণ থেকে প্রস্থান করার সময়, একটি ব্যবহারকারী রেফারেন্স txs ,প্রস্থান tx প্রদান করে এবং একটি ছোট `exit bond` স্থাপন করে একটি প্রস্থান শুরু করতে পারেন। যে কোনও প্রস্থানের জন্য, যদি প্রস্থানটি সফলভাবে চ্যালেঞ্জ করা হয় তবে প্রস্থানটি বাতিল করা হবে এবং প্রস্থান বন্ডটি বাজেয়াপ্ত করা হবে।

## সীমাবদ্ধতা {#limitations}

1.
বড় আকারের প্রুফ: চেকপয়েন্টে ট্রানজেকশনের অধীনে মার্কেল প্রুফ এবং ব্লকের (যার মধ্যে ওই ট্রানজেকশন রয়েছে ) অধীনে  মার্কেল প্রুফ।
2. ব্যাপকভাবে প্রস্থান: অপারেটর দূষিত হয়ে গেলে, ব্যবহারকারীদের ব্যাপকভাবে প্রস্থান করা শুরু করতে হবে।


স্পেকটি তার প্রাথমিক পর্যায়ে আছে এবং যদি এই নির্মাণটি হতাশাজনকভাবে ভেঙে যায়, আমরা যে কোনো প্রতিক্রিয়ার প্রশংসা করব যা আমাদের এটি উন্নত করতে বা সম্পূর্ণরূপে পুনরায় ডিজাইন করতে সহায়তা করবে। বাস্তবায়নটি হচ্ছে আমাদের [কন্ট্রাক্ট](https://github.com/maticnetwork/contracts) রিপোজিটরিতে অগ্রগতির একটি কাজ।