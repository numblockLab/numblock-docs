---
id: account_based_plasma
title: Plasma ที่ใช้บัญชีเป็นหลัก
description: การดำเนินการตามบัญชีของ Plasma
keywords:
  - docs
  - matic
  - Account Based Plasma
  - polygon
  - implementation
image: https://matic.network/banners/matic-network-16x9.png
---

# Plasma ที่ใช้บัญชีเป็นหลัก {#account-based-plasma}

Polygon Plasma ทำตามรูปแบบที่คล้ายกับ [Plasma MoreVP](https://ethresear.ch/t/more-viable-plasma/2160) แต่เป็น**การนำไปใช้ที่ใช้บัญชีเป็นหลัก** เมื่อเปรียบเทียบกับการนำไปใช้ที่ใช้ UTXO เป็นหลักอื่นๆSidechain VM เข้ากันได้กับ EVMเราตัดความจำเป็นในการใช้การลงนามเพื่อการยืนยันออกไปด้วยการใช้โครงสร้าง MoreVP ได้อีกด้วย

## เลเยอร์ PoS และเช็คพอยต์ {#pos-layer-and-checkpoints}

เครือข่าย Polygon ใช้สองกลยุทธ์ควบคู่กัน ได้แก่ Proof of Stake ในเลเยอร์การสร้างเช็คพอยต์และผู้สร้างบล็อกในเลเยอร์ผู้สร้างบล็อก เพื่อให้ได้เวลาในการสร้างบล็อกที่เร็วกว่า และได้ความมีผลสมบูรณ์ในเชนหลักผ่านการใช้เช็คพอยต์และหลักฐานพิสูจน์การฉ้อโกง

เลเยอร์การสร้างเช็คพอยต์ของเครือข่าย Polygon สำหรับทุก 2-3 บล็อกในเลเยอร์บล็อกของเครือข่าย Polygon ตัวตรวจสอบความถูกต้อง (ที่มีการผูกมัดเพียงพอ) จะสร้างเช็คพอยต์ในเชนหลักหลังจากได้ตรวจสอบความถูกต้องของบล็อกทั้งหมดในเลเยอร์บล็อกและสร้าง Merkle Tree ของแฮชของบล็อก นับตั้งแต่เช็คพอยต์ล่าสุด

นอกจากการให้ความมีผลสมบูรณ์ในเชนหลักแล้ว เช็คพอยต์ยังมีบทบาทในการถอน เนื่องจากเช็คพอยต์จะประกอบด้วย Proof-of-Burn (การถอน) ของโทเค็นในกรณีผู้ใช้ดำเนินการถอนนอกจากนี้ ยังทำให้ผู้ใช้สามารถพิสูจน์โทเค็นที่เหลืออยู่ในสัญญาต้นทางได้ โดยใช้ Patricia Merkle Proof และการพิสูจน์บล็อกส่วนหัวโปรดทราบว่า เพื่อพิสูจน์โทเค็นคงเหลือ ต้องคอมมิตบล็อกส่วนหัวกับเชนต้นทางผ่าน PoS (ผู้มีส่วนได้เสีย)กระบวนการถอนจะมีค่าแก๊ส Ethereum ตามปกติเราใช้เช็คพอยต์อย่างหนักกับกลวิธีในการออก

## บันทึกอีเวนต์แบบ UTXO {#utxo-like-event-logs}

ในส่วนการโอน ERC20/ERC721 เราสามารถดำเนินการได้ผ่านการใช้โครงสร้างข้อมูลบันทึกอีเวนต์แบบ UTXOคุณสามารถดูอีเวนต์ `LogTransfer` เพื่อเป็นตัวอย่างอ้างอิงได้ที่ด้านล่าง

```jsx
event LogTransfer(
    address indexed token,
    address indexed from,
    address indexed to,
    uint256 amountOrTokenId,
    uint256 input1, // previous account balance of the sender
    uint256 input2, // previous account balance of the receiver
    uint256 output1, // new account balance of the sender
    uint256 output2 // new account balance of the receiver
);
```

ดังนั้น โดยพื้นฐานแล้ว ในการโอน ERC20/ERC721 ทุกครั้ง จะมีการสร้างอีเวนต์นี้ และยอดคงเหลือก่อนหน้าของผู้ส่งและผู้รับ ( `input1` และ `input2`) จะกลายเป็นอิตพุต (แบบ UTXO) ในธุรกรรมและยอดคงเหลือใหม่จะกลายเป็นเอาต์พุต (`output1` และ `output2`)มีการติดตามการโอนผ่านการรวบรวมอีเวนต์ `LogTransfer` ทั้งหมดที่เกี่ยวข้อง

## กลวิธีในการออก {#exit-games}

เนื่องจากมีการสร้างบล็อกโดยผู้สร้างบล็อกรายเดียว (หรือน้อยมากๆ) จึงต้องรับความเสี่ยงเกี่ยวกับการฉ้อโกงเราจะพูดถึงสถานการณ์ในการโจมตีต่างๆ สั้นๆ และหลังจากนั้น เราจะดูวิธีการซึ่ง Plasma ใช้ในการับประกันความปลอดภัยของผู้ใช้

## วิธีการโจมตี {#attack-vectors}

### ตัวดำเนินการแบบอันตราย {#malicious-operator}
ต่อไปนี้ เราจะกล่าวถึงสถานการณ์ที่ตัวดำเนินการอาจกลายเป็นอันตรายและพยายามฉ้อโกง

1. โทเค็นที่ไม่มีแหล่งที่มา / การชำระซ้ำ / ใบเสร็จผิดปกติที่ใช้การฉ้อโกงเพื่อทำให้ยอดคงเหลือของโทเค็นเพิ่มขึ้น (สำหรับบัญชีที่ตัวดำเนินการควบคุม) / หรือลดลง (สำหรับผู้ใช้)
2. ความไม่พร้อมใช้งานของข้อมูล หลังจากผู้ใช้ส่งธุรกรรมแล้ว สมมติว่าตัวดำเนินการได้รวมธุรกรรมนั้นลงในบล็อก Plasma แต่ทำให้ผู้ใช้ไม่สามารถเข้าใช้งานข้อมูลในเชนได้ในกรณีนี้ หากผู้ใช้เริ่มต้นการออกจากธุรกรรมที่เก่ากว่า พวกเขาอาจได้รับการคัดค้านในเชนด้วยการแสดงธุรกรรมล่าสุดของตนซึ่งง่ายต่อการสร้างปัญหาให้กับผู้ใช้
3. เช็คพอยต์ที่ไม่ดี ในกรณีแย่ที่สุด ตัวดำเนินการสามารถดำเนินการตาม A.1 และ (หรือ) A.2 และร่วมมือกับตัวตรวจสอบความถูกต้องเพื่อคอมมิตการย้ายสถานะที่ผิดพลาดนั้นไปยังเชนต้นทาง
4. การหยุดใช้งานไซด์เชน ตัวดำเนินการหยุดสร้างบล็อก และเชนหยุดการทำงานหากไม่ได้ส่งเช็คพอยต์ในระยะเวลาที่กำหนด จะสามารถทำเครื่องหมายไซด์เชนเป็น "หยุดทำงาน" ในเชนต้นทางได้หลังจากนั้น จะไม่สามารถส่งเช็คพอยต์ได้แล้ว

เนื่องด้วยเหตุผลที่ระบุไว้ด้านบน หรือหากเชน Plasma ประสบปัญหาเนื่องจากสาเหตุอื่นๆ ผู้ใช้ต้องเริ่มดำเนินการออกเป็นกลุ่มใหญ่ และเราต้องการเสนอโครงสร้างการออกในเชนต้นทาง ซึ่งผู้ใช้สามารถใช้ได้ หากกรณีและเวลานั้นมาถึง

### ผู้ใช้ที่ผิดพลาด {#malicious-user}

1. ผู้ใช้เริ่มออกจากธุรกรรมที่คอมมิต แต่ยังมีการดำเนินการชำระโทเค็นในไซด์เชนต่อเรื่องนี้คล้ายกับการชำระซ้ำ แต่ใช้ระหว่าง 2 เชน

เรากำลังดำเนินการสร้างตามแนวคิดของ [MoreVp 7](https://ethresear.ch/t/more-viable-plasma/2160)โดยสรุป MoreVP เสนอวิธีการใหม่ในการคำนวณลำดับความสำคัญในการออก ซึ่งเรียกว่าลำดับความสำคัญ “youngest-input”แทนที่จะสั่งให้ออกตามความเก่าของผลลัพธ์ moreVP จะสั่งให้ออกตามความเก่าของอินพุตที่ใหม่ที่สุดซึ่งผลที่เกิดขึ้นคือ การออกจากเอาต์พุต แม้ว่าจะรวมอยู่ในบล็อกที่ระงับไว้หลังจากธุรกรรม "ที่ไม่มีที่มา" จะมีการดำเนินการอย่างถูกต้องก็ต่อเมื่อมีการสร้างจากอินพุตที่ถูกต้องเรานิยาม `getAge` ซึ่งกำหนดอายุธุรกรรมที่รวมอยู่ซึ่งเป็นไปตามที่นิยามไว้ใน [Minimal Viable Plasma 1](https://ethresear.ch/t/minimal-viable-plasma/426)

```jsx
function getAge(receipt) {
  const { headerNumber, plasmaBlockNum, txindex, oindex } = receipt
  return f(headerNumber, plasmaBlockNum, txindex, oindex) // multiplied with their respective weights
}
```

## สถานการณ์การออก {#exit-scenarios}

มาแนะนำศัพท์ก่อนที่จะคุยกันสถานการณ์การออกจากกัน:

- **ผู้ถอน**: ผู้ใช้ซึ่งประสงค์ออกจากเชน Plasma
- **ธุรกรรมที่คอมมิต**: ธุรกรรมที่รวมอยู่ในบล็อกของเชน Polygon และผ่านการสร้างเช็คพอยต์ในเชนต้นทาง
- **ธุรกรรมการใช้จ่าย**: ธุรกรรมซึ่งเปลี่ยนยอดคงเหลือโทเค็นของผู้ใช้ตามการดำเนินการที่ผู้ใช้ลงนาม (ไม่รวมถึงการรับโอนโทเค็น)ซึ่งอาจเป็นการโอนที่ผู้ใช้เริ่มต้น ธุรกรรมการเบิร์น ฯลฯ
- **ธุรกรรมอ้างอิง**: ธุรกรรมที่ดำเนินการก่อนธุรกรรมการออกสำหรับผู้ใช้และโทเค็นเฉพาะตามที่กำหนดไว้ในโครงสร้าง UTXO ที่ใช้ยอดคงเหลือของบัญชีเป็นหลัก เอาต์พุตที่ได้จากธุรกรรมอ้างอิงจะกลายเป็นอินพุตในธุรกรรมที่ตัวอินพุตออกมา
- **ลำดับความสำคัญในการออก MoreVP** ความเก่าของอินพุตที่ใหม่ที่สุด (ระหว่างธุรกรรมอ้างอิง) ต่อธุรกรรมเฉพาะส่วนใหญ่แล้ว มักจะใช้ในการคำนวณลำดับความสำคัญในการออก

### เผาโทเค็น {#burn-tokens}

เพื่อออกจากไซด์เชน ผู้ใช้จะเริ่มธุรกรรมการ*ถอนหรือเบิร์นโทเค็น*ในเชน Plasmaธุรกรรมนี้จะปล่อยอีเวนต์ `Withdraw`

```jsx
event Withdraw(
    address indexed token,
    address indexed from,
    uint256 amountOrTokenId,
    uint256 input1,
    uint256 output1
);
```

ในที่นี้ `input1` แสดงถึงยอดคงเหลือเดิมของผู้ใช้สำหรับโทเค็นที่เกี่ยวข้อง และ `output1` แสดงถึงจำนวนโทเค็นที่เหลืออยู่ในไซด์เชนโครงสร้างนี้สอดคล้องกับบัญชีของเราซึ่งใช้โครงสร้าง *UTXO* ที่ใช้บัญชีเป็นหลักของเราผู้ใช้จะแสดงการรับของธุรกรรมการถอนนี้เพื่อถอนโทเค็นในเชนหลักในขณะที่อ้างอิงการรับนี้ ผู้ใช้ต้องแสดงรายการดังต่อไปนี้ด้วย:

1. Merkle Proof ในการรวมการรับในบล็อกของไซด์เชน (`receiptsRoot`)
2. Merkle Proof เกี่ยวกับการรวมธุรกรรมในบล็อกไซด์เชน (`transactionsRoot`)
3. หลักฐานการรวมส่วนหัวของบล็อกของไซด์เชนลงในเช็คพอยต์ในเชนต้นทาง

```jsx
startExit(withdrawTx, proofOfInclusion /* of the withdrawTx in the checkpoint */) {
  Verify inclusion of withdrawTx in checkpoint using proofOfInclusion
  Verify msg.sender == ecrecover(withdrawTx)

  uint age = getAge(withdrawTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}
```

เมื่อผู้ใช้ต้องการออกจากเชน Plasma ผู้ใช้ (หรือถอนออกโดยแอปไคลเอ็นต์ของตน เช่น วอลเล็ต) ต้องเบิร์นโทเค็นในไซด์เชน รอรับการสร้างเช็คพอยต์ แล้วเริ่มการออกจากธุรกรรมการถอนที่ผ่านเช็คพอยต์

### ออกจากระบบสุดท้าย ERC20/721 การโอน (MOREVP) {#exit-from-the-last-erc20-721-transfers-morevp}

พิจารณาถึงสถานการณ์ ผู้ใช้ได้ดำเนินการโอน ERC20 ในไซด์เชนตัวดำเนินการได้เพิ่มธุรกรรมซึ่งไม่มีแหล่งที่มาก่อนการโอนของผู้ใช้ และร่วมกับตัวตรวจสอบความถูกต้องในการสร้างเช็คพอยต์สำหรับบล็อกนี้ในสถานการณ์นี้และสถานการณ์ที่ปกติยิ่งกว่า ในการโจมตี A1 ถึง A3 ที่เราได้ระบุไว้ด้านบน ผู้ใช้อาจไม่เคยมีโอกาสเบิร์นโทเค็นของตนก่อนมีการรวมธุรกรรมไม่ประสงค์ดี ดังนั้น ผู้ใช้ต้องเริ่มการออกจากธุรกรรมล่าสุดที่ผ่านเช็คพอยต์ในเชนต้นทาง ด้วยเหตุนี้ นอกจากการออกจากการเบิร์นแล้ว เรายังต้องรองรับการออกจากธุรกรรมต่างๆ เช่น การโอน ERC20/721 เป็นต้นด้วยการใช้วิธีการโจมตีนี้เป็นพื้นฐาน เราแบ่งสถานการณ์ออกเป็น 2 สถานการณ์:

**การโอนออก** ฉันได้โอนโทเค็นจำนวนหนึ่งไปยังผู้ใช้ แต่อย่างไรก็ดี ฉันยังได้สังเกตว่า ตัวดำเนินการได้รวมธุรกรรมไม่ประสงค์ดีในบล็อก/เช็คพอยต์ ก่อนมีการรวมธุรกรรมการโอนของฉันฉันต้องเริ่มดำเนินการออกจากเชนฉันจะเริ่มการออกจากธุรกรรมการโอนตามที่กำหนดไว้ใน MoreVP ฉันจะต้องให้ธุรกรรมอ้างอิง (*อินพุต UTXO*) ซึ่งจะกำหนดลำดับความสำคัญในการออกสำหรับการออกนั้นดังนั้นฉันจะอ้างอิงธุรกรรมที่ได้อัปเดตยอดคงเหลือของโทเค็นของฉัน และได้ดำเนินการก่อนธุรกรรมการโอนออก

```jsx
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the user after the input tx was executed >= tokens being transferred in the exitTx
  Verify msg.sender == ecrecover(exitTx)

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

**การโอนเข้า:** ฉันสังเกตเห็นว่าตัวดำเนินการได้รวมธุรกรรมไม่ประสงค์ดีในบล็อก/เช็คพอยต์ ก่อนที่จะรวมธุรกรรมการโอนเข้าของฉัน ฉันจะเริ่มการออกจากธุรกรรมการโอนเข้า ในขณะที่อ้างอิงยอดคงเหลือของคู่กรณี เพราะว่า*อินพุต UTXO*  เป็นยอดคงเหลือของโทเค็นของคู่กรณี

```
startExit(referenceTx, proofOfInclusion, exitTx) {
  Verify inclusion of referenceTx in checkpoint using proofOfInclusion
  Verify token balance for the counterparty after the input tx was executed >= tokens being transferred in the exitTx
  Verify input.sender == ecrecover(exitTx) && input.receiver == msg.sender

  uint age = getAge(referenceTx)
  // add exit to priority Q
  PlasmaExit exit = ({owner, age, amount, token})
  addExitToQueue(exit)
}

```

### การส่งออกจากธุรกรรมแบบอิน-เที่ยวบิน (MOREVP) {#exit-from-an-in-flight-transaction-morevp}

สถานการณ์นี้เป็นการจัดการกับปัญหาความไม่พร้อมใช้งานของข้อมูลสมมติว่า ฉันสร้างธุรกรรมขึ้น แต่ฉันไม่ทราบว่าได้มีการรวมธุรกรรมนั้นหรือไม่ เนื่องจากความไม่พร้อมใช้งานของข้อมูล ฉันสามารถเริ่มการออกจากธุรกรรมแบบ In-Flight นี้ได้ โดยการอ้างอิงธุรกรรมที่ผ่านเช็คพอยต์ล่าสุดผู้ใช้ควรระมัดระวังโดยไม่ทำธุรกรรมใดๆ เมื่อเริ่มการออกจากรูปแบบ MoreVP มิฉะนั้นอาจได้รับการคัดค้านได้

**หมายเหตุ:** เมื่อออกจากโครงสร้างรูปแบบ MoreVP ผู้ใช้สามารถเริ่มการออกโดยการแสดงธุรกรรมอ้างอิง ธุรกรรมการออก และวาง `exit bond` ไว้เล็กน้อยในทุกๆ การออก หากการคัดค้านการออกประสบความสำเร็จ จะมีการยกเลิกการออก และจะยึดบอนด์สำหรับการออกไว้

## ข้อจำกัด {#limitations}

1. หลักฐานขนาดใหญ่: Merkle Proof ของการรวมธุรกรรมและหลักฐาน Merkle Proof ของการรวมบล็อก (ซึ่งประกอบด้วยธุรกรรมนั้น) ในเช็คพอยต์
2. การออกจำนวนมาก: หากตัวดำเนินการกลายเป็นอันตราย ผู้ใช้จำเป็นต้องเริ่มการออกจำนวนมาก

ข้อมูลจำเพาะนี้อยู่ในขั้นตอนเริ่มต้น และเรายินดีรับฟังทุกความคิดเห็นที่ช่วยให้เราปรับปรุงให้ดียิ่งขึ้น หรือออกแบบใหม่ร่วมกัน หากโครงสร้างนี้เสียดายแบบแก้ไขไม่ได้การดำเนินการคือการทำงานในความก้าวหน้าในไดเรกทอรีการฝากลับของ[สัญญา](https://github.com/maticnetwork/contracts)ของเรา