---
id: consensus
title: ฉันทามติ Bor
description: กลไก Bor สำหรับดึงตัวสร้างสรรค์ใหม่
keywords:
  - docs
  - matic
  - Bor Consensus
  - polygon
image: https://matic.network/banners/matic-network-16x9.png
---
import useBaseUrl from '@docusaurus/useBaseUrl';

# ฉันทามติ Bor {#bor-consensus}

ฉันทามติ Bor ได้รับแรงบันดาลใจจากคอนเซ็นต์ของ Clique: [https://eips.ethereum.org/EIPS/eip-225](https://eips.ethereum.org/EIPS/eip-225)Cliqueทำงานร่วมกับผู้สร้างสรรค์ที่กำหนดไว้ล่วงหน้าหลายรายการผู้สร้างบล็อกทั้งหมดโหวตผู้สร้างบล็อกรายใหม่โดยใช้ Clique APIพวกเขาจะเปลี่ยนการสร้างบล็อก

Bor ดึงข้อมูลผู้สร้างบล็อกรายใหม่ผ่านกลไกการจัดการ Span และ Sprint

## ตัวตรวจสอบความถูกต้อง {#validators}

Polygon เป็นระบบ Proof of Stakeบุคคลใดก็สามารถเดิมพันโทเค็น Matic ของตนบนสัญญาอัจฉริยะ Ethereum ได้ ซึ่งเป็น "สัญญาการเดิมพัน" และกลายเป็นตัวตรวจสอบความถูกต้องสำหรับระบบ

```jsx
function stake(
	uint256 amount,
	uint256 heimdallFee,
	address signer,
	bool acceptDelegation
) external;
```

ในทันทีที่ตัวตรวจสอบความถูกต้องใช้งานได้บน Heimdall ก็จะถูกเลือกเป็นผู้สร้างบล็อกผ่านทางโมดูล `bor`

ตรวจสอบภาพรวมของ Bor เพื่อทำความเข้าใจการจัดการของ Span เพิ่มเติมในรายละเอียด: [ภาพ](https://www.notion.so/Bor-Overview-c8bdb110cd4d4090a7e1589ac1006bab)รวม Bor

## Span {#span}

ชุดบล็อกที่กำหนดไว้ตามลอจิกสำหรับชุดตัวตรวจสอบความถูกต้องถูกเลือกจากท่ามกลางตัวตรวจสอบความถูกต้องที่มีอยู่ทั้งหมดHeimdall แสดงรายละเอียดของ Span ผ่านทาง API รายละเอียด Span

```go
// HeimdallSpan represents span from heimdall APIs
type HeimdallSpan struct {
	Span
	ValidatorSet      ValidatorSet `json:"validator_set" yaml:"validator_set"`
	SelectedProducers []Validator  `json:"selected_producers" yaml:"selected_producers"`
	ChainID           string       `json:"bor_chain_id" yaml:"bor_chain_id"`
}

// Span represents a current bor span
type Span struct {
	ID         uint64 `json:"span_id" yaml:"span_id"`
	StartBlock uint64 `json:"start_block" yaml:"start_block"`
	EndBlock   uint64 `json:"end_block" yaml:"end_block"`
}

// Validator represents a volatile state for each Validator
type Validator struct {
	ID               uint64         `json:"ID"`
	Address          common.Address `json:"signer"`
	VotingPower      int64          `json:"power"`
	ProposerPriority int64          `json:"accum"`
}
```

Geth (ได้แก่ Bor ในกรณีนี้) ใช้บล็อก `snapshot` จัดเก็บข้อมูลสถานะสำหรับแต่ละบล็อก โดยรวมถึงข้อมูลเกี่ยวกับฉันทามติ

ตัวตรวจสอบความถูกต้องแต่ละตัวใน Span มีอำนาจในการโหวตโดยจะได้รับเลือกให้เป็นผู้สร้างบล็อกตามอำนาจของตัวเองยิ่งมีอำนาจสูง ก็จะยิ่งมีความน่าจะเป็นสูงขึ้นในการเป็นผู้สร้างบล็อกBor ใช้อัลกอริทึมของ Tendermint ในการดำเนินการดังกล่าวที่มา: [https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go](https://github.com/maticnetwork/bor/blob/master/consensus/bor/validator_set.go)

## Sprint {#sprint}

ชุดบล็อกภายใน Span ที่เลือกผู้สร้างบล็อกเพียงรายเดียวให้สร้างบล็อกขนาดสปริงเป็นปัจจัยของขนาด SpanBor ใช้  `validatorSet` เพื่อรับผู้เสนอ/ผู้สร้างบล็อกล่าสุดสำหรับ Sprint ล่าสุด

```go
currentProposerForSprint := snap.ValidatorSet().Proposer
```

นอกจากผู้เสนอปัจจุบันแล้ว Bor ยังเลือกผู้สร้างบล็อกสำรองอีกด้วย

## การอนุญาตบล็อก {#authorizing-a-block}

ผู้สร้างบล็อกใน Bor หรือเรียกอีกอย่างว่าผู้ลงนาม เนื่องจากผู้สร้างบล็อกจำเป็นต้องลงนามในแฮชของบล็อกที่มี **ทุกสิ่งทุกอย่างยกเว้นลายเซ็น** เพื่ออนุญาตบล็อกสำหรับเครือข่ายซึ่งหมายความว่าแฮชมีทุกฟิลด์ของส่วนหัว และยังมี `extraData`ยกเว้นของส่วนต่อท้ายลายเซ็น 65 ไบต์อีกด้วย

แฮชนี้ลงนามโดยใช้เส้นโค้งมาตรฐาน `secp256k1` และลายเซ็น 65 ไบต์ที่ได้จะถูกฝังลงใน `extraData` โดยเป็นส่วนต่อท้าย 65 ไบต์

แต่ละบล็อกที่ลงนามจะถูกกำหนดความยากที่เพิ่มน้ำหนักบนบล็อกการลงนามในรอบมีน้ำหนัก (`DIFF_INTURN`) มากกว่าการลงนามนอกรอบหนึ่งครั้ง (`DIFF_NOTURN`)

### กลยุทธ์การอนุญาต {#authorization-strategies}

ตราบใดที่ผู้สร้างบล็อกปฏิบัติตามข้อกำหนดข้างต้น ก็จะสามารถอนุญาตและแจกจ่ายบล็อกได้ตามที่เห็นสมควรอย่างไรก็ตาม กลยุทธ์ที่แนะนำต่อไปนี้จะลดปริมาณการใช้งานเครือข่ายและฟอร์คขนาดเล็ก ดังนั้นจึงเป็นคุณสมบัติที่แนะนำ:

- ในกรณีที่ผู้สร้างบล็อกได้รับอนุญาตให้ลงนามในบล็อก (อยู่ในรายชื่อที่ได้รับอนุญาต)
    - คำนวณเวลาลงนามที่เหมาะสมที่สุดของบล็อกถัดไป (บล็อกหลัก + `Period`)
    - ถ้าผู้ผลิตอยู่ในรอบ ให้รอเวลาที่แน่ชัดที่จะมาถึง ลงนามและเผยแพร่ทันที
    - หากผู้ผลิตบล็อกอยู่นอกรอบ ให้เลื่อนเวลาการลงนามออกไป  `wiggle`

กลยุทธ์เล็กน้อยนี้จะช่วยให้มั่นใจได้ว่าผู้สร้างบล็อกในรอบ (ซึ่งมีบล็อกที่มีน้ำหนักมากกว่า) มีข้อได้เปรียบเล็กน้อยในการลงนามและเผยแพร่ เมื่อเทียบกับผู้ลงนามนอกรอบนอกจากนี้ แผนการนี้ยังช่วยให้มีขนาดเพิ่มขึ้นด้วยการเพิ่มจำนวนผู้สร้างบล็อก

### การลงนามนอกรอบ {#out-of-turn-signing}

Bor เลือกผู้สร้างบล็อกหลายรายเพื่อเป็นผู้สร้างบล็อกสำรอง เมื่อผู้สร้างบล็อกในรอบสร้างบล็อกไม่ได้ซึ่งอาจเกิดขึ้นได้จากหลายสาเหตุ เช่น:

- โหนดผู้สร้างบล็อกทำงานไม่ได้
- ผู้สร้างบล็อกพยายามระงับบล็อก
- ผู้สร้างบล็อกไม่ได้เจตนาสร้างบล็อก

เมื่อเกิดเหตุการณ์ข้างต้น กลไกสำรองของ Bor จะเริ่มทำงาน

ชุดตัวตรวจสอบความถูกต้องจะถูกจัดเก็บเป็นอาร์เรย์ที่จัดเรียงตามที่อยู่ของผู้ลงนามในเวลาใดๆ ก็ตามสมมติว่าชุดตัวตรวจสอบความถูกต้องเรียงลำดับเป็น A, B, C, D และถึงรอบของ C ในการสร้างบล็อกหาก C ไม่สร้างบล็อกภายในเวลาที่เพียงพอ ก็จะถึงรอบของ D ในการสร้างบล็อกถ้า D ไม่สร้าง ก็จะถึงรอบของ A แล้วก็ B

อย่างไรก็ตาม เนื่องจากจะมีการเว้นระยะก่อนที่ C จะสร้างและเผยแพร่บล็อก ตัวตรวจสอบความถูกต้องสำรองจะรอตามระยะเวลาหนึ่งก่อนที่จะเริ่มสร้างบล็อกการเลื่อนเวลานี้เรียกกว่า Wiggle

### Wiggle {#wiggle}

Wiggle หมายถึงเวลาที่ผู้สร้างบล็อกควรรอก่อนที่จะเริ่มสร้างบล็อก

- สมมติว่าบล็อกสุดท้าย (n-1) สร้างขึ้นเมื่อเวลา `t`
- เราบังคับใช้การเลื่อนเวลาขั้นต่ำระหว่างบล็อกปัจจุบันกับบล็อกถัดไปโดยใช้พารามิเตอร์ตัวแปร `Period`
- ในเงื่อนไขที่ควรจะเป็น C จะรอเป็นเวลา `Period` แล้วจึงสร้างและเผยแพร่บล็อกเนื่องจากเวลาของบล็อกบน Polygon ถูกออกแบบให้ค่อนข้างต่ำ (2-4 วินาที) จึงถือว่าการเลื่อนเวลาเผยแพร่เป็นค่าเดียวกับ `Period`
- ดังนั้น หาก D ไม่เห็นบล็อกใหม่ทันเวลา `2 * Period` D จะเริ่มสร้างบล็อกทันทีโดยเฉพาะอย่างยิ่ง เวลา Wiggle ของ D จะถูกกำหนดเป็น `2 * Period * (pos(d) - pos(c))` โดยที่ `pos(d) = 3` และ `pos(c) = 2` ในชุดตัวตรวจสอบความถูกต้อง โดยสมมุติว่า `Period = 1` ซึ่งเป็น Wiggle สำหรับ D เท่ากับ 2 วินาที
- ตอนนี้ หาก D ก็ไม่ได้สร้างบล็อก A จะเริ่มสร้างบล็อกเมื่อเวลา Wiggle `2 * Period * (pos(a) + len(validatorSet) - pos(c)) = 4s` ผ่านไปแล้ว
- ในทำนองเดียวกัน Wiggle สำหรับ C จะเท่ากับ `6s`

### การแก้ปัญหาฟอร์ค {#resolving-forks}

แม้ว่ากลไกข้างต้นจะทำให้เชนมีความทนทานเพิ่มขึ้นในระดับหนึ่ง แต่ก็ทำให้สามารถเกิดฟอร์คได้จริงๆ แล้ว อาจเป็นไปได้ว่า C สร้างบล็อกแล้ว แต่มีความล่าช้าเกินคาดในการเผยแพร่ ด้วยเหตุนี้ D จึงสร้างบล็อกด้วย ด้วยเหตุนี้ จึงทำให้เกิดฟอร์คอย่างน้อย 2 ทาง

ซึ่งสามารถแก้ปัญหาได้ง่ายๆ โดยเลือกเชนที่มีความยากมากกว่าแต่ก็จะมีคำถามว่าเราจะกำหนดความยากของบล็อกในการตั้งค่าของเราได้อย่างไร

### ความยาก {#difficulty}

- ความยากสำหรับบล็อกที่สร้างโดยผู้ลงนามในรอบ (สมมติว่า C) ถูกกำหนดให้มีค่าสูงสุด = `len(validatorSet)`
- เนื่องจาก D เป็นผู้สร้างบล็อกที่อยู่ในลำดับถัดไป หากเกิดสถานการณ์ที่ D สร้างบล็อก ความยากสำหรับบล็อกจะถูกกำหนดเช่นเดียวกับใน Wiggle โดยเป็น `len(validatorSet) - (pos(d) - pos(c))` ซึ่งเท่ากับ `len(validatorSet) - 1`
- ความยากสำหรับบล็อกที่ A สร้างขึ้นในขณะที่ทำหน้าที่เป็นผู้สร้างบล็อกสำรองจะกลายเป็น `len(validatorSet) - (pos(a) + len(validatorSet) - pos(c))` ซึ่งเท่ากับ `2`

เมื่อได้กำหนดความยากของแต่ละบล็อกแล้ว ความยากของฟอร์คก็คือผลรวมของความยากของบล็อกในฟอร์คนั้นในกรณีที่ต้องเลือกฟอร์ค จะเลือกฟอร์คที่มีความยากสูงกว่า เนื่องจากแสดงว่าบล็อกถูกสร้างขึ้นโดยผู้สร้างบล็อกในรอบซึ่งจะให้ความรู้สึกชี้ขาดแก่ผู้ใช้บน Bor

## การเปลี่ยนมุมมอง {#view-change}

ภายหลัง Span แต่ละครั้ง Bor จะเปลี่ยนมุมมองซึ่งหมายความว่าจะดึงข้อมูลผู้สร้างบล็อกใหม่สำหรับ Span ครั้งต่อไป

### ยอมรับ Span {#commit-span}

เมื่อ Span ปัจจุบันกำลังจะสิ้นสุด (โดยเฉพาะอย่างยิ่งเมื่อสิ้นสุด Sprint รองสุดท้ายใน Span) Bor จะดึง Span ใหม่จาก Heimdallซึ่งเป็นการเรียก HTTP ธรรมดาไปยังโหนด Heimdallเมื่อดึงข้อมูลนี้แล้ว ก็จะใช้การเรียกระบบเพื่อเรียก `commitSpan` ไปยังสัญญา Genesis ที่ชื่อ BorValidatorSet

นอกจากนี้ Bor ยังกำหนดค่าไบต์ผู้สร้างบล็อกในส่วนหัวของบล็อกอีกด้วยซึ่งมีความจำเป็นในขณะที่ซิงค์ Bor อย่างรวดเร็วในขณะที่ซิงค์อย่างรวดเร็ว Bor จะซิงค์ส่วนหัวเป็นกลุ่ม และตรวจสอบว่าบล็อกถูกสร้างขึ้นโดยผู้สร้างบล็อกที่ได้รับอนุญาตหรือไม่

เมื่อเริ่มต้น Sprint แต่ละครั้ง Bor จะดึงข้อมูลไบต์ของส่วนหัวจากส่วนหัวก่อนหน้าสำหรับผู้สร้างบล็อกถัดไป และเริ่มสร้างบล็อกตามอัลกอริทึม `ValidatorSet`

ส่วนหัวจะมีลักษณะดังนี้สำหรับบล็อก:

```js
header.Extra = header.Vanity + header.ProducerBytes /* optional */ + header.Seal
```

<img src={useBaseUrl("img/Bor/header-bytes.svg")} />

## การซิงค์สถานะจากเชน Ethereum {#state-sync-from-ethereum-chain}

Bor มีกลไกที่ส่งต่อบางเหตุการณ์บนเชน Ethereum หลักไปยัง Borซึ่งเป็นวิธีการประมวลผลการฝากเงินในสัญญา Plasma

1. สัญญาใดๆ บน Ethereum ก็สามารถเรียก [syncState](https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L33) ใน `StateSender.sol` ได้การเรียกนี้จะส่งเหตุการณ์ `StateSynced`: https://github.com/maticnetwork/contracts/blob/develop/contracts/root/stateSyncer/StateSender.sol#L38

  ```js
  event StateSynced(uint256 indexed id, address indexed contractAddress, bytes data)
  ```

2. Heimdall จะรอรับเหตุการณ์และ`function proposeState(uint256 stateId)`โทรเข้าเหล่านี้ `StateReceiver.sol`จึงทำหน้าที่เป็นร้านสำหรับไอดีการเปลี่ยนสถานะที่รออยู่โปรดทราบว่าธุรกรรม `proposeState` จะถูกประมวลผล แม้จะไม่มีค่าธรรมเนียมแก๊สก็ตาม ตราบใดที่ทำขึ้นโดยตัวตรวจสอบความถูกต้องตัวหนึ่งในชุดตัวตรวจสอบความถูกต้องปัจจุบัน: https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/StateReceiver.sol#L24

3. เมื่อเริ่มต้น Sprint ทุกครั้ง Bor จะดึงรายละเอียดเกี่ยวกับการเปลี่ยนสถานะที่รอดำเนินการ โดยใช้สถานะจาก Heimdall และใช้การเรียกระบบยอมรับการเปลี่ยนดังกล่าวต่อสถานะของ Borดู `commitState` ที่นี่: https://github.com/maticnetwork/genesis-contracts/blob/f85d0409d2a99dff53617ad5429101d9937e3fc3/contracts/StateReceiver.sol#L41
