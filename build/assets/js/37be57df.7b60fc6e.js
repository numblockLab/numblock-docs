"use strict";(self.webpackChunknumblock_docs=self.webpackChunknumblock_docs||[]).push([[4358],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),l=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(i.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),h=a,m=u["".concat(i,".").concat(h)]||u[h]||d[h]||r;return n?o.createElement(m,s(s({ref:t},p),{},{components:n})):o.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=h;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c[u]="string"==typeof e?e:a,s[1]=c;for(var l=2;l<r;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8948:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var o=n(7462),a=(n(7294),n(3905));const r={id:"pos-concepts",title:"Proof of Stake"},s=void 0,c={unversionedId:"foundational-topics/consensus-mechanism/pos-concepts",id:"foundational-topics/consensus-mechanism/pos-concepts",title:"Proof of Stake",description:"Overview",source:"@site/docs/foundational-topics/consensus-mechanism/pos-concepts.md",sourceDirName:"foundational-topics/consensus-mechanism",slug:"/foundational-topics/consensus-mechanism/pos-concepts",permalink:"/docs/foundational-topics/consensus-mechanism/pos-concepts",draft:!1,tags:[],version:"current",frontMatter:{id:"pos-concepts",title:"Proof of Stake"},sidebar:"develop",previous:{title:"BLS",permalink:"/docs/foundational-topics/consensus-mechanism/bls"},next:{title:"State in NumBlock",permalink:"/docs/foundational-topics/state"}},i={},l=[{value:"Overview",id:"overview",level:2},{value:"Staking",id:"staking",level:3},{value:"Epochs",id:"epochs",level:3},{value:"Epoch Blocks",id:"epoch-blocks",level:2}],p={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Numblock consensus algorithm is a sophisticated and robust consensus mechanism employed by NumBlock. The consensus mechanism comprises two key components, a consensus engine and consensus protocol. NumBlock consensus utilizes the IBFT consensus engine and a Proof-of-Stake architecture to seal blocks, provide specific network capabilities, and govern the network. The core smart contracts work in tandem with the consensus engine to define all the network's Proof-of-Stake rules"),(0,a.kt)("p",null,"The consensus engine of NumBlock is based on the Istanbul Byzantine Fault Tolerance (IBFT 2.0) protocol, which is responsible for sealing blocks on the blockchain. The IBFT 2.0 protocol ensures that network integrity is maintained even in the presence of malicious or dishonest nodes."),(0,a.kt)("h3",{id:"staking"},"Staking"),(0,a.kt)("p",null,"Staking is managed by staking contracts on the Polygon network. The staking module on Polygon validates staked tokens and is independent of Ethereum's security. In principle, the network is secured by the rootchain and Ethereum. Transaction checkpoints still occur on Ethereum, but Ethereum does not validate staking on Polygon."),(0,a.kt)("p",null,"At the end of each epoch, a reward calculation occurs to reward validators who actively participated in that epoch."),(0,a.kt)("h3",{id:"epochs"},"Epochs"),(0,a.kt)("p",null,"Epochs are a concept introduced with the addition of PoS to the NumBlock."),(0,a.kt)("p",null,"Epochs are considered to be a special time frame (in blocks) in which a certain set of validators can produce blocks.\nTheir lengths are modifiable, meaning node operators can configure the length of an epoch during genesis generation."),(0,a.kt)("p",null,"At the end of each epoch, an ",(0,a.kt)("em",{parentName:"p"},"epoch block")," is created, and after that event a new epoch starts. To learn more about\nepoch blocks, see the ",(0,a.kt)("a",{parentName:"p",href:"/docs/foundational-topics/consensus-mechanism/pos-concepts#epoch-blocks"},"Epoch Blocks")," section."),(0,a.kt)("p",null,"Validator sets are updated at the end of each epoch. Nodes query the validator set from the Staking Smart Contract\nduring the creation of the epoch block, and save the obtained data to local storage. This query and save cycle is\nrepeated at the end of each epoch."),(0,a.kt)("p",null,"Essentially, it ensures that the Staking Smart Contract has full control over the addresses in the validator set, and\nleaves nodes with only 1 responsibility - to query the contract once during an epoch for fetching the latest validator\nset information. This alleviates the responsibility from individual nodes from taking care of validator sets."),(0,a.kt)("h2",{id:"epoch-blocks"},"Epoch Blocks"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Epoch Blocks")," are a concept introduced in the PoS implementation of IBFT in NumBlock. ",(0,a.kt)("strong",{parentName:"p"},"Epoch size")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"50")," blocks\non NumBlock"))}u.isMDXComponent=!0}}]);