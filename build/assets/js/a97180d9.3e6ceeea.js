"use strict";(self.webpackChunknumblock_docs=self.webpackChunknumblock_docs||[]).push([[585],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=a,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||i;return n?o.createElement(m,r(r({ref:t},u),{},{components:n})):o.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1279:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const i={id:"bls",title:"BLS",description:"Explanation and instructions regarding BLS mode.",keywords:["docs","numblock","bls"]},r=void 0,s={unversionedId:"foundational-topics/consensus-mechanism/bls",id:"foundational-topics/consensus-mechanism/bls",title:"BLS",description:"Explanation and instructions regarding BLS mode.",source:"@site/docs/foundational-topics/consensus-mechanism/bls.md",sourceDirName:"foundational-topics/consensus-mechanism",slug:"/foundational-topics/consensus-mechanism/bls",permalink:"/docs/foundational-topics/consensus-mechanism/bls",draft:!1,tags:[],version:"current",frontMatter:{id:"bls",title:"BLS",description:"Explanation and instructions regarding BLS mode.",keywords:["docs","numblock","bls"]},sidebar:"develop",previous:{title:"Delegation",permalink:"/docs/foundational-topics/consensus-mechanism/delegation"},next:{title:"Proof of Stake",permalink:"/docs/foundational-topics/consensus-mechanism/pos-concepts"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",id:"istanbul-byzantine-fault-tolerant-ibft-20",level:2},{value:"Consensus Engine",id:"consensus-engine",level:2},{value:"Validator Set",id:"validator-set",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"BLS also known as Boneh\u2013Lynn\u2013Shacham (BLS)\u2014is a cryptographic signature scheme which allows a user to verify that a signer is authentic. It is a signature scheme that can aggregate multiple signatures. In NumBlock, BLS is used by default in order to provide better security in the IBFT consensus mode. BLS can aggregate signatures into a single byte array and reduce the block header size. Each chain can choose whether to use BLS or not. The ECDSA key is used regardless of whether the BLS mode is enabled or not."),(0,a.kt)("h2",{id:"istanbul-byzantine-fault-tolerant-ibft-20"},"Istanbul Byzantine Fault Tolerant (IBFT) 2.0"),(0,a.kt)("p",null,"Istanbul Byzantine Fault Tolerant (IBFT) 2.0 is a consensus algorithm for blockchain networks that was developed as part of the Ethereum platform's transition to Proof of Stake (PoS) consensus. It is an improvement on the original IBFT algorithm, which was developed for private blockchain networks."),(0,a.kt)("p",null,"IBFT 2.0 is designed to be highly secure and fault-tolerant, meaning that it can maintain consensus even in the presence of malicious actors or other types of network failures. This makes it well-suited for use in public blockchain networks, where security and reliability are of utmost importance."),(0,a.kt)("p",null,"The key features of IBFT 2.0 include:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Byzantine Fault Tolerance: The algorithm is designed to tolerate up to one-third of the network's nodes acting in a Byzantine or malicious manner, without compromising the security or consistency of the network.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Finality: Unlike some other consensus algorithms, IBFT 2.0 provides immediate finality, meaning that once a block is added to the chain, it cannot be reversed or changed.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Efficient block propagation: IBFT 2.0 uses a gossip protocol to efficiently propagate new blocks across the network, reducing latency and improving performance."))),(0,a.kt)("p",null,"Overall, IBFT 2.0 is a robust and secure consensus algorithm that is well-suited for use in public blockchain networks that require high levels of security and fault tolerance."),(0,a.kt)("h2",{id:"consensus-engine"},"Consensus Engine"),(0,a.kt)("p",null,"The NumBlock consensus (NumBlockBFT) mechanism uses the IBFT 2.0 consensus engine to agree on adding new blocks to the blockchain. The validator pool in IBFT 2.0 is responsible for validating candidate blocks proposed by a randomly selected block proposer who is part of the validator pool. The proposer is responsible for constructing a block at the block interval. The proposer mechanism is based on ",(0,a.kt)("strong",{parentName:"p"},"Tendermint"),", where a proposer is chosen based on a deterministic selection algorithm. The frequency of selection is proportional to the voting power of the validator."),(0,a.kt)("p",null,"Each block in IBFT 2.0 requires at least one round of voting by the validator to arrive at consensus, which is recorded as a collection of signatures on the block content. In general, a supermajority of validators must confirm that a block is valid for the block to be added to the blockchain. Only when there is no consensus on a given block, multiple rounds of voting are needed. The ideal path would be when the validator pool reaches consensus on a candidate block in the first round of voting, and the block is added to the blockchain without the need for additional rounds of voting. This is the most efficient and optimal outcome, as it allows the network to continue processing transactions and adding new blocks to the chain in a timely manner."),(0,a.kt)("p",null,"A validator's voting power is proportional to the amount of stake they have locked up on the network. This means that validators with more stake will have more voting power and, therefore, more influence over the decision-making process on the network. This also provides an economic incentive for validators to behave honestly and act in the network's best interest."),(0,a.kt)("h2",{id:"validator-set"},"Validator Set"),(0,a.kt)("p",null,"NumBlock consensus algorithm limits network participation to around 100 validators, and a variable amount of stake is used as a fixed stake criterion to limit the system's security and can make the system economically vulnerable. The validator set in the NumBlock consensus does not update on each block but is fixed during n block periods known as an epoch."),(0,a.kt)("p",null,"The n block period to define one epoch is determined by governance, and until then, validators will remain the same. At the end of the epoch, a special state transaction to validatorSetManagementContract is emitted, notifying the system about the validators' uptime during the epoch. It is up to the smart contract to reward validators by their uptime and update the validator set for the next epoch. There is a function getValidatorSet which returns the current validator set at any time."))}d.isMDXComponent=!0}}]);