"use strict";(self.webpackChunknumblock_docs=self.webpackChunknumblock_docs||[]).push([[6804],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),d=a,h=p["".concat(s,".").concat(d)]||p[d]||m[d]||l;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var c=2;c<l;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9557:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const l={id:"other-modules",title:"Other modules"},o=void 0,i={unversionedId:"architecture/modules/other-modules",id:"architecture/modules/other-modules",title:"Other modules",description:"Minimal",source:"@site/docs/architecture/modules/other-modules.md",sourceDirName:"architecture/modules",slug:"/architecture/modules/other-modules",permalink:"/docs/architecture/modules/other-modules",draft:!1,tags:[],version:"current",frontMatter:{id:"other-modules",title:"Other modules"},sidebar:"develop",previous:{title:"NumBlock Native Bridge",permalink:"/docs/architecture/modules/native-bridge"},next:{title:"Developers",permalink:"/docs/category/developers"}},s={},c=[{value:"Minimal",id:"minimal",level:2},{value:"Sealer",id:"sealer",level:2},{value:"Types",id:"types",level:2},{value:"RLP Encoding / Decoding",id:"rlp-encoding--decoding",level:3},{value:"Crypto",id:"crypto",level:2},{value:"Chain",id:"chain",level:2},{value:"Helper",id:"helper",level:2},{value:"Command",id:"command",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"minimal"},"Minimal"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Minimal")," is the cornerstone for these inter-connected modules. ",(0,a.kt)("br",null),"\nIt acts as a central hub for all the services that run on the NumBlock."),(0,a.kt)("h2",{id:"sealer"},"Sealer"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Sealer")," is an entity that gathers the transactions, and creates a new block.",(0,a.kt)("br",null),"\nThen, that block is sent to the ",(0,a.kt)("strong",{parentName:"p"},"Consensus")," module to seal it."),(0,a.kt)("p",null,"The final sealing logic is located within the ",(0,a.kt)("strong",{parentName:"p"},"Consensus")," module."),(0,a.kt)("h2",{id:"types"},"Types"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Types")," module implements core object types, such as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Address")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Hash")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Header")),(0,a.kt)("li",{parentName:"ul"},"lots of helper functions")),(0,a.kt)("h3",{id:"rlp-encoding--decoding"},"RLP Encoding / Decoding"),(0,a.kt)("p",null,"Unlike clients such as GETH, the NumBlock doesn't use reflection for the encoding.",(0,a.kt)("br",null),"\nThe preference was to not use reflection because it introduces new problems, such as performance\ndegradation, and harder scaling."),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Types")," module provides an easy-to-use interface for RLP marshaling and unmarshalling, using the FastRLP package."),(0,a.kt)("p",null,"Marshaling is done through the ",(0,a.kt)("em",{parentName:"p"},"MarshalRLPWith")," and ",(0,a.kt)("em",{parentName:"p"},"MarshalRLPTo")," methods. The analogous methods exist for\nunmarshalling."),(0,a.kt)("p",null,"By manually defining these methods, the NumBlock doesn't need to use reflection. In ",(0,a.kt)("em",{parentName:"p"},"rlp_marshal.go"),", you can find\nmethods for marshaling:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Bodies")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Blocks")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Headers")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Receipts")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Logs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Transactions"))),(0,a.kt)("h2",{id:"crypto"},"Crypto"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Crypto")," module contains crypto utility functions."),(0,a.kt)("h2",{id:"chain"},"Chain"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Chain")," module contains chain parameters (active forks, consensus engine, etc.)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"chains")," - Predefined chain configurations (mainnet, goerli, ibft)")),(0,a.kt)("h2",{id:"helper"},"Helper"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Helper")," module contains helper packages."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"dao")," - Dao utils"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"enode")," - Enode encoding/decoding function"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"hex")," - Hex encoding/decoding functions"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ipc")," - IPC connection functions"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"keccak")," - Keccak functions"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"rlputil")," - Rlp encoding/decoding helper function")),(0,a.kt)("h2",{id:"command"},"Command"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Command")," module contains interfaces for CLI commands."))}p.isMDXComponent=!0}}]);